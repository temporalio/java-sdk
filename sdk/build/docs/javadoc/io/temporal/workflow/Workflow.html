<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>Workflow (sdk 0.29.1-SNAPSHOT API)</title>
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Workflow (sdk 0.29.1-SNAPSHOT API)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":9,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9,"i14":9,"i15":9,"i16":9,"i17":9,"i18":9,"i19":9,"i20":9,"i21":9,"i22":9,"i23":9,"i24":9,"i25":9,"i26":9,"i27":9,"i28":9,"i29":9,"i30":9,"i31":9,"i32":9,"i33":9,"i34":9,"i35":9,"i36":9,"i37":9,"i38":9,"i39":9,"i40":9,"i41":9,"i42":9,"i43":9,"i44":9,"i45":9,"i46":9,"i47":9,"i48":9,"i49":9,"i50":9,"i51":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../io/temporal/workflow/SignalMethod.html" title="annotation in io.temporal.workflow"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../io/temporal/workflow/WorkflowInfo.html" title="interface in io.temporal.workflow"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?io/temporal/workflow/Workflow.html" target="_top">Frames</a></li>
<li><a href="Workflow.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">io.temporal.workflow</div>
<h2 title="Class Workflow" class="title">Class Workflow</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>io.temporal.workflow.Workflow</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public final class <span class="typeNameLabel">Workflow</span>
extends java.lang.Object</pre>
<div class="block">Workflow encapsulates the orchestration of activities and child workflows. It can also answer to
 synchronous queries and receive external events (also known as signals).

 <h2>Workflow Interface</h2>

 A workflow must define an interface class. All of its methods must have one of the following
 annotations:

 <ul>
   <li>@<a href="../../../io/temporal/workflow/WorkflowMethod.html" title="annotation in io.temporal.workflow"><code>WorkflowMethod</code></a> indicates an entry point to a workflow. It contains
       parameters such as timeouts and a task queue. Required parameters (like <code>workflowRunTimeoutSeconds</code>) that are not specified through the annotation must be provided
       at runtime.
   <li>@<a href="../../../io/temporal/workflow/SignalMethod.html" title="annotation in io.temporal.workflow"><code>SignalMethod</code></a> indicates a method that reacts to external signals. It
       must have a <code>void</code> return type.
   <li>@<a href="../../../io/temporal/workflow/QueryMethod.html" title="annotation in io.temporal.workflow"><code>QueryMethod</code></a> indicates a method that reacts to synchronous query
       requests. You can have more than one method with the same annotation.
 </ul>

 <pre><code>
 public interface FileProcessingWorkflow {

     @WorkflowMethod(workflowRunTimeoutSeconds = 10, taskQueue = "file-processing")
     String processFile(Arguments args);

     @QueryMethod(name="history")
     List<String> getHistory();

     @QueryMethod(name="status")
     String getStatus();

     @SignalMethod
     void retryNow();
 }
 </code></pre>

 <h2>Starting workflow executions</h2>

 See <a href="../../../io/temporal/client/WorkflowClient.html" title="interface in io.temporal.client"><code>WorkflowClient</code></a>

 <h2>Implementing Workflows</h2>

 A workflow implementation implements a workflow interface. Each time a new workflow execution is
 started, a new instance of the workflow implementation object is created. Then, one of the
 methods (depending on which workflow type has been started) annotated with @<a href="../../../io/temporal/workflow/WorkflowMethod.html" title="annotation in io.temporal.workflow"><code>WorkflowMethod</code></a> is invoked. As soon as this method returns the workflow, execution is closed.
 While workflow execution is open, it can receive calls to signal and query methods. No additional
 calls to workflow methods are allowed. The workflow object is stateful, so query and signal
 methods can communicate with the other parts of the workflow through workflow object fields.

 <h3>Calling Activities</h3>

 <a href="../../../io/temporal/workflow/Workflow.html#newActivityStub-java.lang.Class-"><code>newActivityStub(Class)</code></a> returns a client-side stub that implements an activity interface.
 It takes activity type and activity options as arguments. Activity options are needed only if
 some of the required timeouts are not specified through the @<a href="../../../io/temporal/activity/ActivityMethod.html" title="annotation in io.temporal.activity"><code>ActivityMethod</code></a> annotation.

 <p>Calling a method on this interface invokes an activity that implements this method. An
 activity invocation synchronously blocks until the activity completes, fails, or times out. Even
 if activity execution takes a few months, the workflow code still sees it as a single synchronous
 invocation. Isn't it great? It doesn't matter what happens to the processes that host the
 workflow. The business logic code just sees a single method call.

 <pre><code>
 public class FileProcessingWorkflowImpl implements FileProcessingWorkflow {

     private final FileProcessingActivities activities;

     public FileProcessingWorkflowImpl() {
         this.store = Workflow.newActivityStub(FileProcessingActivities.class);
     }

     @Override
     public void processFile(Arguments args) {
         String localName = null;
         String processedName = null;
         try {
             localName = activities.download(args.getSourceBucketName(), args.getSourceFilename());
             processedName = activities.processFile(localName);
             activities.upload(args.getTargetBucketName(), args.getTargetFilename(), processedName);
         } finally {
             if (localName != null) { // File was downloaded.
                 activities.deleteLocalFile(localName);
             }
             if (processedName != null) { // File was processed.
                 activities.deleteLocalFile(processedName);
             }
         }
     }
     ...
 }
 </code></pre>

 If different activities need different options, like timeouts or a task queue, multiple
 client-side stubs can be created with different options.

 <pre><code>
 public FileProcessingWorkflowImpl() {
     ActivityOptions options1 = ActivityOptions.newBuilder()
         .setTaskQueue("taskQueue1")
         .build();
     this.store1 = Workflow.newActivityStub(FileProcessingActivities.class, options1);

     ActivityOptions options2 = ActivityOptions.newBuilder()
         .setTaskQueue("taskQueue2")
         .build();
     this.store2 = Workflow.newActivityStub(FileProcessingActivities.class, options2);
 }
 </code></pre>

 <h3>Calling Activities Asynchronously</h3>

 Sometimes workflows need to perform certain operations in parallel. The <a href="../../../io/temporal/workflow/Async.html" title="class in io.temporal.workflow"><code>Async</code></a> static
 methods allow you to invoke any activity asynchronously. The call returns a <a href="../../../io/temporal/workflow/Promise.html" title="interface in io.temporal.workflow"><code>Promise</code></a>
 result immediately. <a href="../../../io/temporal/workflow/Promise.html" title="interface in io.temporal.workflow"><code>Promise</code></a> is similar to both <code>Future</code> and
 <code>CompletionStage</code>. The <a href="../../../io/temporal/workflow/Promise.html#get--"><code>Promise.get()</code></a> blocks until a result is
 available. It also exposes the <a href="../../../io/temporal/workflow/Promise.html#thenApply-io.temporal.workflow.Functions.Func1-"><code>Promise.thenApply(Functions.Func1)</code></a> and <a href="../../../io/temporal/workflow/Promise.html#handle-io.temporal.workflow.Functions.Func2-"><code>Promise.handle(Functions.Func2)</code></a> methods. See the <a href="../../../io/temporal/workflow/Promise.html" title="interface in io.temporal.workflow"><code>Promise</code></a> documentation for technical
 details about differences with <code>Future</code>.

 <p>To convert a synchronous call

 <pre><code>
 String localName = activities.download(sourceBucket, sourceFile);
 </code></pre>

 to asynchronous style, the method reference is passed to <a href="../../../io/temporal/workflow/Async.html#function-io.temporal.workflow.Functions.Func-"><code>Async.function(Functions.Func)</code></a>
 or <a href="../../../io/temporal/workflow/Async.html#procedure-io.temporal.workflow.Functions.Proc-"><code>Async.procedure(Functions.Proc)</code></a> followed by activity arguments:

 <pre><code>
 Promise<String> localNamePromise = Async.function(activities::download, sourceBucket, sourceFile);
 </code></pre>

 Then to wait synchronously for the result:

 <pre><code>
 String localName = localNamePromise.get();
 </code></pre>

 Here is the above example rewritten to call download and upload in parallel on multiple files:

 <pre><code>
 public void processFile(Arguments args) {
     List&lt;Promise&lt;String&gt;&gt; localNamePromises = new ArrayList&lt;&gt;();
     List&lt;String&gt; processedNames = null;
     try {
         // Download all files in parallel.
         for (String sourceFilename : args.getSourceFilenames()) {
             Promise&lt;String&gt; localName = Async.function(activities::download, args.getSourceBucketName(), sourceFilename);
             localNamePromises.add(localName);
         }
         // allOf converts a list of promises to a single promise that contains a list of each promise value.
         Promise&lt;List&lt;String&gt;&gt; localNamesPromise = Promise.allOf(localNamePromises);

         // All code until the next line wasn't blocking.
         // The promise get is a blocking call.
         List&lt;String&gt; localNames = localNamesPromise.get();
         processedNames = activities.processFiles(localNames);

         // Upload all results in parallel.
         List&lt;Promise&lt;Void&gt;&gt; uploadedList = new ArrayList&lt;&gt;();
         for (String processedName : processedNames) {
             Promise&lt;Void&gt; uploaded = Async.procedure(activities::upload,
                 args.getTargetBucketName(),
                 args.getTargetFilename(),
                 processedName);
             uploadedList.add(uploaded);
         }
         // Wait for all uploads to complete.
         Promise&lt;?&gt; allUploaded = Promise.allOf(uploadedList);
         allUploaded.get(); // blocks until all promises are ready.
     } finally {
         // Execute deletes even if workflow is canceled.
         Workflow.newDetachedCancellationScope(
             () -&gt; {
                 for (Promise&lt;Sting&gt; localNamePromise : localNamePromises) {
                     // Skip files that haven't completed downloading.
                     if (localNamePromise.isCompleted()) {
                         activities.deleteLocalFile(localNamePromise.get());
                     }
                 }
                 if (processedNames != null) {
                     for (String processedName : processedNames) {
                         activities.deleteLocalFile(processedName);
                     }
                 }
             }
          ).run();
     }
 }
 </code></pre>

 <h3>Child Workflows</h3>

 Besides activities, a workflow can also orchestrate other workflows.

 <p><a href="../../../io/temporal/workflow/Workflow.html#newChildWorkflowStub-java.lang.Class-"><code>newChildWorkflowStub(Class)</code></a> returns a client-side stub that implements a child
 workflow interface. It takes a child workflow type and optional child workflow options as
 arguments. Workflow options may be needed to override the timeouts and task queue if they differ
 from the ones defined in the @<a href="../../../io/temporal/workflow/WorkflowMethod.html" title="annotation in io.temporal.workflow"><code>WorkflowMethod</code></a> annotation or parent workflow.

 <p>The first call to the child workflow stub must always be to a method annotated with
 @<a href="../../../io/temporal/workflow/WorkflowMethod.html" title="annotation in io.temporal.workflow"><code>WorkflowMethod</code></a>. Similarly to activities, a call can be synchronous or
 asynchronous using <a href="../../../io/temporal/workflow/Async.html#function-io.temporal.workflow.Functions.Func-"><code>Async.function(Functions.Func)</code></a> or <a href="../../../io/temporal/workflow/Async.html#procedure-io.temporal.workflow.Functions.Proc-"><code>Async.procedure(Functions.Proc)</code></a>. The synchronous call blocks until a child workflow completes.
 The asynchronous call returns a <a href="../../../io/temporal/workflow/Promise.html" title="interface in io.temporal.workflow"><code>Promise</code></a> that can be used to wait for the completion.
 After an async call returns the stub, it can be used to send signals to the child by calling
 methods annotated with @<a href="../../../io/temporal/workflow/SignalMethod.html" title="annotation in io.temporal.workflow"><code>SignalMethod</code></a>. Querying a child workflow by calling
 methods annotated with @<a href="../../../io/temporal/workflow/QueryMethod.html" title="annotation in io.temporal.workflow"><code>QueryMethod</code></a> from within workflow code is not
 supported. However, queries can be done from activities using the <a href="../../../io/temporal/client/WorkflowClient.html" title="interface in io.temporal.client"><code>WorkflowClient</code></a> provided stub.

 <pre><code>
 public interface GreetingChild {
     @WorkflowMethod
     String composeGreeting(String greeting, String name);
 }

 public static class GreetingWorkflowImpl implements GreetingWorkflow {

     @Override
     public String getGreeting(String name) {
         GreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class);

         // This is a blocking call that returns only after child has completed.
         return child.composeGreeting("Hello", name );
     }
 }
 </code></pre>

 Running two children in parallel:

 <pre><code>
 public static class GreetingWorkflowImpl implements GreetingWorkflow {

     @Override
     public String getGreeting(String name) {

         // Workflows are stateful, so a new stub must be created for each new child.
         GreetingChild child1 = Workflow.newChildWorkflowStub(GreetingChild.class);
         Promise<String> greeting1 = Async.function(child1::composeGreeting, "Hello", name);

         // Both children will run concurrently.
         GreetingChild child2 = Workflow.newChildWorkflowStub(GreetingChild.class);
         Promise<String> greeting2 = Async.function(child2::composeGreeting, "Bye", name);

         // Do something else here.
         ...
         return "First: " + greeting1.get() + ", second=" + greeting2.get();
     }
 }
 </code></pre>

 To send signal to a child, call a method annotated with @<a href="../../../io/temporal/workflow/SignalMethod.html" title="annotation in io.temporal.workflow"><code>SignalMethod</code></a>:

 <pre><code>
 public interface GreetingChild {
     @WorkflowMethod
     String composeGreeting(String greeting, String name);

     @SignalMethod
     void updateName(String name);
 }

 public static class GreetingWorkflowImpl implements GreetingWorkflow {

     @Override
     public String getGreeting(String name) {
         GreetingChild child = Workflow.newChildWorkflowStub(GreetingChild.class);
         Promise<String> greeting = Async.function(child::composeGreeting, "Hello", name);
         child.updateName("Temporal");
         return greeting.get();
     }
 }
 </code></pre>

 Calling methods annotated with @<a href="../../../io/temporal/workflow/QueryMethod.html" title="annotation in io.temporal.workflow"><code>QueryMethod</code></a> is not allowed from within a
 workflow code.

 <h3>Workflow Implementation Constraints</h3>

 Temporal uses <a
 href="https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing">event
 sourcing</a> to recover the state of a workflow object including its threads and local variable
 values. In essence, every time a workflow state has to be restored, its code is re-executed from
 the beginning. When replaying, side effects (such as activity invocations) are ignored because
 they are already recorded in the workflow event history. When writing workflow logic, the replay
 is not visible, so the code should be written as it executes only once. This design puts the
 following constraints on the workflow implementation:

 <ul>
   <li>Do not use any mutable global variables because multiple instances of workflows are
       executed in parallel.
   <li>Do not call any non deterministic functions like non seeded random or <code>UUID.randomUUID()</code> directly form the workflow code. Always do this in activities.
   <li>Don’t perform any IO or service calls as they are not usually deterministic. Use activities
       for this.
   <li>Only use <a href="../../../io/temporal/workflow/Workflow.html#currentTimeMillis--"><code>currentTimeMillis()</code></a> to get the current time inside a workflow.
   <li>Do not use native Java <code>Thread</code> or any other multi-threaded classes like <code>ThreadPoolExecutor</code>. Use <a href="../../../io/temporal/workflow/Async.html#function-io.temporal.workflow.Functions.Func-"><code>Async.function(Functions.Func)</code></a> or
       <a href="../../../io/temporal/workflow/Async.html#procedure-io.temporal.workflow.Functions.Proc-"><code>Async.procedure(Functions.Proc)</code></a> to execute code asynchronously.
   <li>Don't use any synchronization, locks, and other standard Java blocking concurrency-related
       classes besides those provided by the Workflow class. There is no need in explicit
       synchronization because multi-threaded code inside a workflow is executed one thread at a
       time and under a global lock.
   <li>Call <a href="../../../io/temporal/workflow/Workflow.html#sleep-java.time.Duration-"><code>sleep(Duration)</code></a> instead of <code>Thread.sleep(long)</code>.
   <li>Use <a href="../../../io/temporal/workflow/Promise.html" title="interface in io.temporal.workflow"><code>Promise</code></a> and <a href="../../../io/temporal/workflow/CompletablePromise.html" title="interface in io.temporal.workflow"><code>CompletablePromise</code></a> instead of <code>Future</code> and <code>CompletableFuture</code>.
   <li>Use <a href="../../../io/temporal/workflow/WorkflowQueue.html" title="interface in io.temporal.workflow"><code>WorkflowQueue</code></a> instead of <code>BlockingQueue</code>.
   <li>Don't change workflow code when there are open workflows. The ability to do updates through
       visioning is TBD.
   <li>Don’t access configuration APIs directly from a workflow because changes in the
       configuration might affect a workflow execution path. Pass it as an argument to a workflow
       function or use an activity to load it.
 </ul>

 <p>Workflow method arguments and return values are serializable to a byte array using the
 provided <a href="../../../io/temporal/common/converter/DataConverter.html" title="interface in io.temporal.common.converter"><code>DataConverter</code></a>. The default implementation uses the
 JSON serializer, but any alternative serialization mechanism is pluggable.

 <p>The values passed to workflows through invocation parameters or returned through a result
 value are recorded in the execution history. The entire execution history is transferred from the
 Temporal service to workflow workers with every event that the workflow logic needs to process. A
 large execution history can thus adversely impact the performance of your workflow. Therefore, be
 mindful of the amount of data that you transfer via activity invocation parameters or return
 values. Other than that, no additional limitations exist on activity implementations.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#DEFAULT_VERSION">DEFAULT_VERSION</a></span></code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#await-java.time.Duration-java.util.function.Supplier-">await</a></span>(java.time.Duration&nbsp;timeout,
     java.util.function.Supplier&lt;java.lang.Boolean&gt;&nbsp;unblockCondition)</code>
<div class="block">Block current workflow thread until unblockCondition is evaluated to true or timeoutMillis
 passes.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#await-java.util.function.Supplier-">await</a></span>(java.util.function.Supplier&lt;java.lang.Boolean&gt;&nbsp;unblockCondition)</code>
<div class="block">Block current thread until unblockCondition is evaluated to true.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#continueAsNew-java.lang.Object...-">continueAsNew</a></span>(java.lang.Object...&nbsp;args)</code>
<div class="block">Continues the current workflow execution as a new run with the same options.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#continueAsNew-java.util.Optional-java.util.Optional-java.lang.Object...-">continueAsNew</a></span>(java.util.Optional&lt;java.lang.String&gt;&nbsp;workflowType,
             java.util.Optional&lt;<a href="../../../io/temporal/workflow/ContinueAsNewOptions.html" title="class in io.temporal.workflow">ContinueAsNewOptions</a>&gt;&nbsp;options,
             java.lang.Object...&nbsp;args)</code>
<div class="block">Continues the current workflow execution as a new run possibly overriding the workflow type and
 options.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>static long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#currentTimeMillis--">currentTimeMillis</a></span>()</code>
<div class="block">Must be used to get current time instead of <code>System.currentTimeMillis()</code> to guarantee
 determinism.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>static <a href="../../../io/temporal/workflow/WorkflowInfo.html" title="interface in io.temporal.workflow">WorkflowInfo</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#getInfo--">getInfo</a></span>()</code>&nbsp;</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>static &lt;R&gt;&nbsp;R</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#getLastCompletionResult-java.lang.Class-">getLastCompletionResult</a></span>(java.lang.Class&lt;R&gt;&nbsp;resultClass)</code>
<div class="block">GetLastCompletionResult extract last completion result from previous run for this cron
 workflow.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>static &lt;R&gt;&nbsp;R</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#getLastCompletionResult-java.lang.Class-java.lang.reflect.Type-">getLastCompletionResult</a></span>(java.lang.Class&lt;R&gt;&nbsp;resultClass,
                       java.lang.reflect.Type&nbsp;resultType)</code>
<div class="block">GetLastCompletionResult extract last completion result from previous run for this cron
 workflow.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>static org.slf4j.Logger</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#getLogger-java.lang.Class-">getLogger</a></span>(java.lang.Class&lt;?&gt;&nbsp;clazz)</code>
<div class="block">Get logger to use inside workflow.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>static org.slf4j.Logger</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#getLogger-java.lang.String-">getLogger</a></span>(java.lang.String&nbsp;name)</code>
<div class="block">Get logger to use inside workflow.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>static com.uber.m3.tally.Scope</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#getMetricsScope--">getMetricsScope</a></span>()</code>
<div class="block">Get scope for reporting business metrics in workflow logic.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#getVersion-java.lang.String-int-int-">getVersion</a></span>(java.lang.String&nbsp;changeId,
          int&nbsp;minSupported,
          int&nbsp;maxSupported)</code>
<div class="block"><code>getVersion</code> is used to safely perform backwards incompatible changes to workflow
 definitions.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>static <a href="../../../io/temporal/workflow/Promise.html" title="interface in io.temporal.workflow">Promise</a>&lt;io.temporal.api.common.v1.WorkflowExecution&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#getWorkflowExecution-java.lang.Object-">getWorkflowExecution</a></span>(java.lang.Object&nbsp;childWorkflowStub)</code>
<div class="block">Extracts workflow execution from a stub created through <a href="../../../io/temporal/workflow/Workflow.html#newChildWorkflowStub-java.lang.Class-io.temporal.workflow.ChildWorkflowOptions-"><code>newChildWorkflowStub(Class,
 ChildWorkflowOptions)</code></a> or <a href="../../../io/temporal/workflow/Workflow.html#newExternalWorkflowStub-java.lang.Class-java.lang.String-"><code>newExternalWorkflowStub(Class, String)</code></a>.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#isReplaying--">isReplaying</a></span>()</code>
<div class="block">True if workflow code is being replayed.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>static &lt;R&gt;&nbsp;R</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#mutableSideEffect-java.lang.String-java.lang.Class-java.util.function.BiPredicate-io.temporal.workflow.Functions.Func-">mutableSideEffect</a></span>(java.lang.String&nbsp;id,
                 java.lang.Class&lt;R&gt;&nbsp;resultClass,
                 java.util.function.BiPredicate&lt;R,R&gt;&nbsp;updated,
                 <a href="../../../io/temporal/workflow/Functions.Func.html" title="interface in io.temporal.workflow">Functions.Func</a>&lt;R&gt;&nbsp;func)</code>
<div class="block"><code>mutableSideEffect</code> is similar to <a href="../../../io/temporal/workflow/Workflow.html#sideEffect-java.lang.Class-io.temporal.workflow.Functions.Func-"><code>sideEffect(Class, Functions.Func)</code></a> in allowing
 calls of non-deterministic functions from workflow code.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>static &lt;R&gt;&nbsp;R</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#mutableSideEffect-java.lang.String-java.lang.Class-java.lang.reflect.Type-java.util.function.BiPredicate-io.temporal.workflow.Functions.Func-">mutableSideEffect</a></span>(java.lang.String&nbsp;id,
                 java.lang.Class&lt;R&gt;&nbsp;resultClass,
                 java.lang.reflect.Type&nbsp;resultType,
                 java.util.function.BiPredicate&lt;R,R&gt;&nbsp;updated,
                 <a href="../../../io/temporal/workflow/Functions.Func.html" title="interface in io.temporal.workflow">Functions.Func</a>&lt;R&gt;&nbsp;func)</code>
<div class="block"><code>mutableSideEffect</code> is similar to <a href="../../../io/temporal/workflow/Workflow.html#sideEffect-java.lang.Class-io.temporal.workflow.Functions.Func-"><code>sideEffect(Class, Functions.Func)</code></a> in allowing
 calls of non-deterministic functions from workflow code.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;T</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#newActivityStub-java.lang.Class-">newActivityStub</a></span>(java.lang.Class&lt;T&gt;&nbsp;activityInterface)</code>
<div class="block">Creates client stub to activities that implement given interface.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;T</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#newActivityStub-java.lang.Class-io.temporal.activity.ActivityOptions-">newActivityStub</a></span>(java.lang.Class&lt;T&gt;&nbsp;activityInterface,
               <a href="../../../io/temporal/activity/ActivityOptions.html" title="class in io.temporal.activity">ActivityOptions</a>&nbsp;options)</code>
<div class="block">Creates client stub to activities that implement given interface.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>static <a href="../../../io/temporal/workflow/CancellationScope.html" title="interface in io.temporal.workflow">CancellationScope</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#newCancellationScope-io.temporal.workflow.Functions.Proc1-">newCancellationScope</a></span>(<a href="../../../io/temporal/workflow/Functions.Proc1.html" title="interface in io.temporal.workflow">Functions.Proc1</a>&lt;<a href="../../../io/temporal/workflow/CancellationScope.html" title="interface in io.temporal.workflow">CancellationScope</a>&gt;&nbsp;proc)</code>
<div class="block">Wraps a procedure in a CancellationScope.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>static <a href="../../../io/temporal/workflow/CancellationScope.html" title="interface in io.temporal.workflow">CancellationScope</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#newCancellationScope-java.lang.Runnable-">newCancellationScope</a></span>(java.lang.Runnable&nbsp;runnable)</code>
<div class="block">Wraps the Runnable method argument in a <a href="../../../io/temporal/workflow/CancellationScope.html" title="interface in io.temporal.workflow"><code>CancellationScope</code></a>.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;T</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#newChildWorkflowStub-java.lang.Class-">newChildWorkflowStub</a></span>(java.lang.Class&lt;T&gt;&nbsp;workflowInterface)</code>
<div class="block">Creates client stub that can be used to start a child workflow that implements the given
 interface using parent options.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;T</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#newChildWorkflowStub-java.lang.Class-io.temporal.workflow.ChildWorkflowOptions-">newChildWorkflowStub</a></span>(java.lang.Class&lt;T&gt;&nbsp;workflowInterface,
                    <a href="../../../io/temporal/workflow/ChildWorkflowOptions.html" title="class in io.temporal.workflow">ChildWorkflowOptions</a>&nbsp;options)</code>
<div class="block">Creates client stub that can be used to start a child workflow that implements given interface.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;T</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#newContinueAsNewStub-java.lang.Class-">newContinueAsNewStub</a></span>(java.lang.Class&lt;T&gt;&nbsp;workflowInterface)</code>
<div class="block">Creates a client stub that can be used to continue this workflow as a new run.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;T</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#newContinueAsNewStub-java.lang.Class-io.temporal.workflow.ContinueAsNewOptions-">newContinueAsNewStub</a></span>(java.lang.Class&lt;T&gt;&nbsp;workflowInterface,
                    <a href="../../../io/temporal/workflow/ContinueAsNewOptions.html" title="class in io.temporal.workflow">ContinueAsNewOptions</a>&nbsp;options)</code>
<div class="block">Creates a client stub that can be used to continue this workflow as a new run.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>static <a href="../../../io/temporal/workflow/CancellationScope.html" title="interface in io.temporal.workflow">CancellationScope</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#newDetachedCancellationScope-java.lang.Runnable-">newDetachedCancellationScope</a></span>(java.lang.Runnable&nbsp;runnable)</code>
<div class="block">Creates a CancellationScope that is not linked to a parent scope.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>static &lt;R&gt;&nbsp;R</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#newExternalWorkflowStub-java.lang.Class-java.lang.String-">newExternalWorkflowStub</a></span>(java.lang.Class&lt;? extends R&gt;&nbsp;workflowInterface,
                       java.lang.String&nbsp;workflowId)</code>
<div class="block">Creates client stub that can be used to communicate to an existing workflow execution.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>static &lt;R&gt;&nbsp;R</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#newExternalWorkflowStub-java.lang.Class-io.temporal.api.common.v1.WorkflowExecution-">newExternalWorkflowStub</a></span>(java.lang.Class&lt;? extends R&gt;&nbsp;workflowInterface,
                       io.temporal.api.common.v1.WorkflowExecution&nbsp;execution)</code>
<div class="block">Creates client stub that can be used to communicate to an existing workflow execution.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>static &lt;E&gt;&nbsp;<a href="../../../io/temporal/workflow/Promise.html" title="interface in io.temporal.workflow">Promise</a>&lt;E&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#newFailedPromise-java.lang.Exception-">newFailedPromise</a></span>(java.lang.Exception&nbsp;failure)</code>&nbsp;</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;T</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#newLocalActivityStub-java.lang.Class-">newLocalActivityStub</a></span>(java.lang.Class&lt;T&gt;&nbsp;activityInterface)</code>
<div class="block">Creates client stub to local activities that implement given interface.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;T</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#newLocalActivityStub-java.lang.Class-io.temporal.activity.LocalActivityOptions-">newLocalActivityStub</a></span>(java.lang.Class&lt;T&gt;&nbsp;activityInterface,
                    <a href="../../../io/temporal/activity/LocalActivityOptions.html" title="class in io.temporal.activity">LocalActivityOptions</a>&nbsp;options)</code>
<div class="block">Creates client stub to local activities that implement given interface.</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>static &lt;E&gt;&nbsp;<a href="../../../io/temporal/workflow/CompletablePromise.html" title="interface in io.temporal.workflow">CompletablePromise</a>&lt;E&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#newPromise--">newPromise</a></span>()</code>&nbsp;</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code>static &lt;E&gt;&nbsp;<a href="../../../io/temporal/workflow/Promise.html" title="interface in io.temporal.workflow">Promise</a>&lt;E&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#newPromise-E-">newPromise</a></span>(E&nbsp;value)</code>&nbsp;</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>static &lt;E&gt;&nbsp;<a href="../../../io/temporal/workflow/WorkflowQueue.html" title="interface in io.temporal.workflow">WorkflowQueue</a>&lt;E&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#newQueue-int-">newQueue</a></span>(int&nbsp;capacity)</code>&nbsp;</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code>static java.util.Random</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#newRandom--">newRandom</a></span>()</code>
<div class="block">Replay safe random numbers generator.</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>static <a href="../../../io/temporal/workflow/Promise.html" title="interface in io.temporal.workflow">Promise</a>&lt;java.lang.Void&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#newTimer-java.time.Duration-">newTimer</a></span>(java.time.Duration&nbsp;delay)</code>
<div class="block">Create new timer.</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>static <a href="../../../io/temporal/workflow/ActivityStub.html" title="interface in io.temporal.workflow">ActivityStub</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#newUntypedActivityStub-io.temporal.activity.ActivityOptions-">newUntypedActivityStub</a></span>(<a href="../../../io/temporal/activity/ActivityOptions.html" title="class in io.temporal.activity">ActivityOptions</a>&nbsp;options)</code>
<div class="block">Creates non typed client stub to activities.</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>static <a href="../../../io/temporal/workflow/ChildWorkflowStub.html" title="interface in io.temporal.workflow">ChildWorkflowStub</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#newUntypedChildWorkflowStub-java.lang.String-">newUntypedChildWorkflowStub</a></span>(java.lang.String&nbsp;workflowType)</code>
<div class="block">Creates untyped client stub that can be used to start and signal a child workflow.</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>static <a href="../../../io/temporal/workflow/ChildWorkflowStub.html" title="interface in io.temporal.workflow">ChildWorkflowStub</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#newUntypedChildWorkflowStub-java.lang.String-io.temporal.workflow.ChildWorkflowOptions-">newUntypedChildWorkflowStub</a></span>(java.lang.String&nbsp;workflowType,
                           <a href="../../../io/temporal/workflow/ChildWorkflowOptions.html" title="class in io.temporal.workflow">ChildWorkflowOptions</a>&nbsp;options)</code>
<div class="block">Creates untyped client stub that can be used to start and signal a child workflow.</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>static <a href="../../../io/temporal/workflow/ExternalWorkflowStub.html" title="interface in io.temporal.workflow">ExternalWorkflowStub</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#newUntypedExternalWorkflowStub-java.lang.String-">newUntypedExternalWorkflowStub</a></span>(java.lang.String&nbsp;workflowId)</code>
<div class="block">Creates untyped client stub that can be used to signal or cancel a child workflow.</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code>static <a href="../../../io/temporal/workflow/ExternalWorkflowStub.html" title="interface in io.temporal.workflow">ExternalWorkflowStub</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#newUntypedExternalWorkflowStub-io.temporal.api.common.v1.WorkflowExecution-">newUntypedExternalWorkflowStub</a></span>(io.temporal.api.common.v1.WorkflowExecution&nbsp;execution)</code>
<div class="block">Creates untyped client stub that can be used to signal or cancel a child workflow.</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code>static <a href="../../../io/temporal/workflow/ActivityStub.html" title="interface in io.temporal.workflow">ActivityStub</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#newUntypedLocalActivityStub-io.temporal.activity.LocalActivityOptions-">newUntypedLocalActivityStub</a></span>(<a href="../../../io/temporal/activity/LocalActivityOptions.html" title="class in io.temporal.activity">LocalActivityOptions</a>&nbsp;options)</code>
<div class="block">Creates non typed client stub to local activities.</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code>static java.util.UUID</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#randomUUID--">randomUUID</a></span>()</code>
<div class="block">Replay safe way to generate UUID.</div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#registerListener-java.lang.Object-">registerListener</a></span>(java.lang.Object&nbsp;listener)</code>
<div class="block">Registers an implementation object.</div>
</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code>static &lt;R&gt;&nbsp;R</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#retry-io.temporal.common.RetryOptions-java.util.Optional-io.temporal.workflow.Functions.Func-">retry</a></span>(<a href="../../../io/temporal/common/RetryOptions.html" title="class in io.temporal.common">RetryOptions</a>&nbsp;options,
     java.util.Optional&lt;java.time.Duration&gt;&nbsp;expiration,
     <a href="../../../io/temporal/workflow/Functions.Func.html" title="interface in io.temporal.workflow">Functions.Func</a>&lt;R&gt;&nbsp;fn)</code>
<div class="block">Invokes function retrying in case of failures according to retry options.</div>
</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#retry-io.temporal.common.RetryOptions-java.util.Optional-io.temporal.workflow.Functions.Proc-">retry</a></span>(<a href="../../../io/temporal/common/RetryOptions.html" title="class in io.temporal.common">RetryOptions</a>&nbsp;options,
     java.util.Optional&lt;java.time.Duration&gt;&nbsp;expiration,
     <a href="../../../io/temporal/workflow/Functions.Proc.html" title="interface in io.temporal.workflow">Functions.Proc</a>&nbsp;proc)</code>
<div class="block">Invokes function retrying in case of failures according to retry options.</div>
</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code>static &lt;R&gt;&nbsp;R</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#sideEffect-java.lang.Class-io.temporal.workflow.Functions.Func-">sideEffect</a></span>(java.lang.Class&lt;R&gt;&nbsp;resultClass,
          <a href="../../../io/temporal/workflow/Functions.Func.html" title="interface in io.temporal.workflow">Functions.Func</a>&lt;R&gt;&nbsp;func)</code>
<div class="block">Executes the provided function once, records its result into the workflow history.</div>
</td>
</tr>
<tr id="i46" class="altColor">
<td class="colFirst"><code>static &lt;R&gt;&nbsp;R</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#sideEffect-java.lang.Class-java.lang.reflect.Type-io.temporal.workflow.Functions.Func-">sideEffect</a></span>(java.lang.Class&lt;R&gt;&nbsp;resultClass,
          java.lang.reflect.Type&nbsp;resultType,
          <a href="../../../io/temporal/workflow/Functions.Func.html" title="interface in io.temporal.workflow">Functions.Func</a>&lt;R&gt;&nbsp;func)</code>
<div class="block">Executes the provided function once, records its result into the workflow history.</div>
</td>
</tr>
<tr id="i47" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#sleep-java.time.Duration-">sleep</a></span>(java.time.Duration&nbsp;duration)</code>
<div class="block">Must be called instead of <code>Thread.sleep(long)</code> to guarantee determinism.</div>
</td>
</tr>
<tr id="i48" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#sleep-long-">sleep</a></span>(long&nbsp;millis)</code>
<div class="block">Must be called instead of <code>Thread.sleep(long)</code> to guarantee determinism.</div>
</td>
</tr>
<tr id="i49" class="rowColor">
<td class="colFirst"><code>static java.lang.Exception</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#unwrap-java.lang.Exception-">unwrap</a></span>(java.lang.Exception&nbsp;e)</code>
<div class="block">Removes <a href="../../../io/temporal/internal/common/CheckedExceptionWrapper.html" title="class in io.temporal.internal.common"><code>CheckedExceptionWrapper</code></a> from causal exception
 chain.</div>
</td>
</tr>
<tr id="i50" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#upsertSearchAttributes-java.util.Map-">upsertSearchAttributes</a></span>(java.util.Map&lt;java.lang.String,java.lang.Object&gt;&nbsp;searchAttributes)</code>
<div class="block"><code>upsertSearchAttributes</code> is used to add or update workflow search attributes.</div>
</td>
</tr>
<tr id="i51" class="rowColor">
<td class="colFirst"><code>static java.lang.RuntimeException</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/workflow/Workflow.html#wrap-java.lang.Exception-">wrap</a></span>(java.lang.Exception&nbsp;e)</code>
<div class="block">If there is a need to return a checked exception from a workflow implementation do not add the
 exception to a method signature but wrap it using this method before rethrowing.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="DEFAULT_VERSION">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>DEFAULT_VERSION</h4>
<pre>public static final&nbsp;int DEFAULT_VERSION</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#io.temporal.workflow.Workflow.DEFAULT_VERSION">Constant Field Values</a></dd>
</dl>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="newActivityStub-java.lang.Class-io.temporal.activity.ActivityOptions-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newActivityStub</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;newActivityStub(java.lang.Class&lt;T&gt;&nbsp;activityInterface,
                                    <a href="../../../io/temporal/activity/ActivityOptions.html" title="class in io.temporal.activity">ActivityOptions</a>&nbsp;options)</pre>
<div class="block">Creates client stub to activities that implement given interface.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>activityInterface</code> - interface type implemented by activities.</dd>
<dd><code>options</code> - options that together with the properties of <a href="../../../io/temporal/activity/ActivityMethod.html" title="annotation in io.temporal.activity"><code>ActivityMethod</code></a> specify the activity invocation parameters.</dd>
</dl>
</li>
</ul>
<a name="newActivityStub-java.lang.Class-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newActivityStub</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;newActivityStub(java.lang.Class&lt;T&gt;&nbsp;activityInterface)</pre>
<div class="block">Creates client stub to activities that implement given interface. `</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>activityInterface</code> - interface type implemented by activities</dd>
</dl>
</li>
</ul>
<a name="newUntypedActivityStub-io.temporal.activity.ActivityOptions-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newUntypedActivityStub</h4>
<pre>public static&nbsp;<a href="../../../io/temporal/workflow/ActivityStub.html" title="interface in io.temporal.workflow">ActivityStub</a>&nbsp;newUntypedActivityStub(<a href="../../../io/temporal/activity/ActivityOptions.html" title="class in io.temporal.activity">ActivityOptions</a>&nbsp;options)</pre>
<div class="block">Creates non typed client stub to activities. Allows executing activities by their string name.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>options</code> - specify the activity invocation parameters.</dd>
</dl>
</li>
</ul>
<a name="newLocalActivityStub-java.lang.Class-io.temporal.activity.LocalActivityOptions-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newLocalActivityStub</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;newLocalActivityStub(java.lang.Class&lt;T&gt;&nbsp;activityInterface,
                                         <a href="../../../io/temporal/activity/LocalActivityOptions.html" title="class in io.temporal.activity">LocalActivityOptions</a>&nbsp;options)</pre>
<div class="block">Creates client stub to local activities that implement given interface. A local activity is
 similar to a regular activity, but with some key differences: 1. Local activity is scheduled
 and run by the workflow worker locally. 2. Local activity does not need Temporal server to
 schedule activity task and does not rely on activity worker. 3. Local activity is for short
 living activities (usually finishes within seconds). 4. Local activity cannot heartbeat.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>activityInterface</code> - interface type implemented by activities.</dd>
<dd><code>options</code> - options that together with the properties of <a href="../../../io/temporal/activity/ActivityMethod.html" title="annotation in io.temporal.activity"><code>ActivityMethod</code></a> specify the activity invocation parameters.</dd>
</dl>
</li>
</ul>
<a name="newLocalActivityStub-java.lang.Class-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newLocalActivityStub</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;newLocalActivityStub(java.lang.Class&lt;T&gt;&nbsp;activityInterface)</pre>
<div class="block">Creates client stub to local activities that implement given interface.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>activityInterface</code> - interface type implemented by activities</dd>
</dl>
</li>
</ul>
<a name="newUntypedLocalActivityStub-io.temporal.activity.LocalActivityOptions-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newUntypedLocalActivityStub</h4>
<pre>public static&nbsp;<a href="../../../io/temporal/workflow/ActivityStub.html" title="interface in io.temporal.workflow">ActivityStub</a>&nbsp;newUntypedLocalActivityStub(<a href="../../../io/temporal/activity/LocalActivityOptions.html" title="class in io.temporal.activity">LocalActivityOptions</a>&nbsp;options)</pre>
<div class="block">Creates non typed client stub to local activities. Allows executing activities by their string
 name.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>options</code> - specify the local activity invocation parameters.</dd>
</dl>
</li>
</ul>
<a name="newChildWorkflowStub-java.lang.Class-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newChildWorkflowStub</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;newChildWorkflowStub(java.lang.Class&lt;T&gt;&nbsp;workflowInterface)</pre>
<div class="block">Creates client stub that can be used to start a child workflow that implements the given
 interface using parent options. Use <a href="../../../io/temporal/workflow/Workflow.html#newExternalWorkflowStub-java.lang.Class-java.lang.String-"><code>newExternalWorkflowStub(Class, String)</code></a> to get a
 stub to signal a workflow without starting it.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>workflowInterface</code> - interface type implemented by activities</dd>
</dl>
</li>
</ul>
<a name="newChildWorkflowStub-java.lang.Class-io.temporal.workflow.ChildWorkflowOptions-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newChildWorkflowStub</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;newChildWorkflowStub(java.lang.Class&lt;T&gt;&nbsp;workflowInterface,
                                         <a href="../../../io/temporal/workflow/ChildWorkflowOptions.html" title="class in io.temporal.workflow">ChildWorkflowOptions</a>&nbsp;options)</pre>
<div class="block">Creates client stub that can be used to start a child workflow that implements given interface.
 Use <a href="../../../io/temporal/workflow/Workflow.html#newExternalWorkflowStub-java.lang.Class-java.lang.String-"><code>newExternalWorkflowStub(Class, String)</code></a> to get a stub to signal a workflow without
 starting it.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>workflowInterface</code> - interface type implemented by activities</dd>
<dd><code>options</code> - options passed to the child workflow.</dd>
</dl>
</li>
</ul>
<a name="newExternalWorkflowStub-java.lang.Class-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newExternalWorkflowStub</h4>
<pre>public static&nbsp;&lt;R&gt;&nbsp;R&nbsp;newExternalWorkflowStub(java.lang.Class&lt;? extends R&gt;&nbsp;workflowInterface,
                                            java.lang.String&nbsp;workflowId)</pre>
<div class="block">Creates client stub that can be used to communicate to an existing workflow execution.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>workflowInterface</code> - interface type implemented by activities</dd>
<dd><code>workflowId</code> - id of the workflow to communicate with.</dd>
</dl>
</li>
</ul>
<a name="newExternalWorkflowStub-java.lang.Class-io.temporal.api.common.v1.WorkflowExecution-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newExternalWorkflowStub</h4>
<pre>public static&nbsp;&lt;R&gt;&nbsp;R&nbsp;newExternalWorkflowStub(java.lang.Class&lt;? extends R&gt;&nbsp;workflowInterface,
                                            io.temporal.api.common.v1.WorkflowExecution&nbsp;execution)</pre>
<div class="block">Creates client stub that can be used to communicate to an existing workflow execution.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>workflowInterface</code> - interface type implemented by activities</dd>
<dd><code>execution</code> - execution of the workflow to communicate with.</dd>
</dl>
</li>
</ul>
<a name="getWorkflowExecution-java.lang.Object-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getWorkflowExecution</h4>
<pre>public static&nbsp;<a href="../../../io/temporal/workflow/Promise.html" title="interface in io.temporal.workflow">Promise</a>&lt;io.temporal.api.common.v1.WorkflowExecution&gt;&nbsp;getWorkflowExecution(java.lang.Object&nbsp;childWorkflowStub)</pre>
<div class="block">Extracts workflow execution from a stub created through <a href="../../../io/temporal/workflow/Workflow.html#newChildWorkflowStub-java.lang.Class-io.temporal.workflow.ChildWorkflowOptions-"><code>newChildWorkflowStub(Class,
 ChildWorkflowOptions)</code></a> or <a href="../../../io/temporal/workflow/Workflow.html#newExternalWorkflowStub-java.lang.Class-java.lang.String-"><code>newExternalWorkflowStub(Class, String)</code></a>. Wrapped in a Promise
 as child workflow start is asynchronous.</div>
</li>
</ul>
<a name="newUntypedChildWorkflowStub-java.lang.String-io.temporal.workflow.ChildWorkflowOptions-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newUntypedChildWorkflowStub</h4>
<pre>public static&nbsp;<a href="../../../io/temporal/workflow/ChildWorkflowStub.html" title="interface in io.temporal.workflow">ChildWorkflowStub</a>&nbsp;newUntypedChildWorkflowStub(java.lang.String&nbsp;workflowType,
                                                            <a href="../../../io/temporal/workflow/ChildWorkflowOptions.html" title="class in io.temporal.workflow">ChildWorkflowOptions</a>&nbsp;options)</pre>
<div class="block">Creates untyped client stub that can be used to start and signal a child workflow.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>workflowType</code> - name of the workflow type to start.</dd>
<dd><code>options</code> - options passed to the child workflow.</dd>
</dl>
</li>
</ul>
<a name="newUntypedChildWorkflowStub-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newUntypedChildWorkflowStub</h4>
<pre>public static&nbsp;<a href="../../../io/temporal/workflow/ChildWorkflowStub.html" title="interface in io.temporal.workflow">ChildWorkflowStub</a>&nbsp;newUntypedChildWorkflowStub(java.lang.String&nbsp;workflowType)</pre>
<div class="block">Creates untyped client stub that can be used to start and signal a child workflow. All options
 are inherited from the parent.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>workflowType</code> - name of the workflow type to start.</dd>
</dl>
</li>
</ul>
<a name="newUntypedExternalWorkflowStub-io.temporal.api.common.v1.WorkflowExecution-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newUntypedExternalWorkflowStub</h4>
<pre>public static&nbsp;<a href="../../../io/temporal/workflow/ExternalWorkflowStub.html" title="interface in io.temporal.workflow">ExternalWorkflowStub</a>&nbsp;newUntypedExternalWorkflowStub(io.temporal.api.common.v1.WorkflowExecution&nbsp;execution)</pre>
<div class="block">Creates untyped client stub that can be used to signal or cancel a child workflow.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>execution</code> - execution of the workflow to communicate with.</dd>
</dl>
</li>
</ul>
<a name="newUntypedExternalWorkflowStub-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newUntypedExternalWorkflowStub</h4>
<pre>public static&nbsp;<a href="../../../io/temporal/workflow/ExternalWorkflowStub.html" title="interface in io.temporal.workflow">ExternalWorkflowStub</a>&nbsp;newUntypedExternalWorkflowStub(java.lang.String&nbsp;workflowId)</pre>
<div class="block">Creates untyped client stub that can be used to signal or cancel a child workflow.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>workflowId</code> - id of the workflow to communicate with.</dd>
</dl>
</li>
</ul>
<a name="newContinueAsNewStub-java.lang.Class-io.temporal.workflow.ContinueAsNewOptions-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newContinueAsNewStub</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;newContinueAsNewStub(java.lang.Class&lt;T&gt;&nbsp;workflowInterface,
                                         <a href="../../../io/temporal/workflow/ContinueAsNewOptions.html" title="class in io.temporal.workflow">ContinueAsNewOptions</a>&nbsp;options)</pre>
<div class="block">Creates a client stub that can be used to continue this workflow as a new run.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>workflowInterface</code> - an interface type implemented by the next run of the workflow</dd>
</dl>
</li>
</ul>
<a name="newContinueAsNewStub-java.lang.Class-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newContinueAsNewStub</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;newContinueAsNewStub(java.lang.Class&lt;T&gt;&nbsp;workflowInterface)</pre>
<div class="block">Creates a client stub that can be used to continue this workflow as a new run.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>workflowInterface</code> - an interface type implemented by the next run of the workflow</dd>
</dl>
</li>
</ul>
<a name="continueAsNew-java.lang.Object...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>continueAsNew</h4>
<pre>public static&nbsp;void&nbsp;continueAsNew(java.lang.Object...&nbsp;args)</pre>
<div class="block">Continues the current workflow execution as a new run with the same options.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>args</code> - arguments of the next run.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../io/temporal/workflow/Workflow.html#newContinueAsNewStub-java.lang.Class-"><code>newContinueAsNewStub(Class)</code></a></dd>
</dl>
</li>
</ul>
<a name="continueAsNew-java.util.Optional-java.util.Optional-java.lang.Object...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>continueAsNew</h4>
<pre>public static&nbsp;void&nbsp;continueAsNew(java.util.Optional&lt;java.lang.String&gt;&nbsp;workflowType,
                                 java.util.Optional&lt;<a href="../../../io/temporal/workflow/ContinueAsNewOptions.html" title="class in io.temporal.workflow">ContinueAsNewOptions</a>&gt;&nbsp;options,
                                 java.lang.Object...&nbsp;args)</pre>
<div class="block">Continues the current workflow execution as a new run possibly overriding the workflow type and
 options.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>options</code> - option overrides for the next run.</dd>
<dd><code>args</code> - arguments of the next run.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../io/temporal/workflow/Workflow.html#newContinueAsNewStub-java.lang.Class-"><code>newContinueAsNewStub(Class)</code></a></dd>
</dl>
</li>
</ul>
<a name="getInfo--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getInfo</h4>
<pre>public static&nbsp;<a href="../../../io/temporal/workflow/WorkflowInfo.html" title="interface in io.temporal.workflow">WorkflowInfo</a>&nbsp;getInfo()</pre>
</li>
</ul>
<a name="newCancellationScope-java.lang.Runnable-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newCancellationScope</h4>
<pre>public static&nbsp;<a href="../../../io/temporal/workflow/CancellationScope.html" title="interface in io.temporal.workflow">CancellationScope</a>&nbsp;newCancellationScope(java.lang.Runnable&nbsp;runnable)</pre>
<div class="block">Wraps the Runnable method argument in a <a href="../../../io/temporal/workflow/CancellationScope.html" title="interface in io.temporal.workflow"><code>CancellationScope</code></a>. The <code>Runnable.run()</code> calls <code>Runnable.run()</code> on the wrapped Runnable. The returned
 CancellationScope can be used to cancel the wrapped code. The cancellation semantic depends on
 the operation the code is blocked on. For example activity or child workflow is first canceled
 then throws a <a href="../../../io/temporal/failure/CanceledFailure.html" title="class in io.temporal.failure"><code>CanceledFailure</code></a>. The same applies for <a href="../../../io/temporal/workflow/Workflow.html#sleep-long-"><code>sleep(long)</code></a>
 operation. When an activity or a child workflow is invoked asynchronously then they get
 canceled and a <a href="../../../io/temporal/workflow/Promise.html" title="interface in io.temporal.workflow"><code>Promise</code></a> that contains their result will throw <a href="../../../io/temporal/failure/CanceledFailure.html" title="class in io.temporal.failure"><code>CanceledFailure</code></a>
 when <a href="../../../io/temporal/workflow/Promise.html#get--"><code>Promise.get()</code></a> is called.

 <p>The new cancellation scope is linked to the parent one (available as <a href="../../../io/temporal/workflow/CancellationScope.html#current--"><code>CancellationScope.current()</code></a>. If the parent one is canceled then all the children scopes are
 canceled automatically. The main workflow function (annotated with @<a href="../../../io/temporal/workflow/WorkflowMethod.html" title="annotation in io.temporal.workflow"><code>WorkflowMethod</code></a> is
 wrapped within a root cancellation scope which gets canceled when a workflow is canceled
 through the Temporal CancelWorkflowExecution API. To perform cleanup operations that require
 blocking after the current scope is canceled use a scope created through <a href="../../../io/temporal/workflow/Workflow.html#newDetachedCancellationScope-java.lang.Runnable-"><code>newDetachedCancellationScope(Runnable)</code></a>.

 <p>Example of running activities in parallel and cancelling them after a specified timeout.

 <pre><code>
     List&lt;Promise&lt;String&gt;&gt; results = new ArrayList&lt;&gt;();
     CancellationScope scope = Workflow.newDetachedCancellationScope(() -&gt; {
        Async.function(activities::a1);
        Async.function(activities::a2);
     });
     scope.run(); // returns immediately as the activities are invoked asynchronously
     Workflow.sleep(Duration.ofHours(1));
     // Cancels any activity in the scope that is still running
     scope.cancel("one hour passed");

 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>runnable</code> - parameter to wrap in a cancellation scope.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>wrapped parameter.</dd>
</dl>
</li>
</ul>
<a name="newCancellationScope-io.temporal.workflow.Functions.Proc1-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newCancellationScope</h4>
<pre>public static&nbsp;<a href="../../../io/temporal/workflow/CancellationScope.html" title="interface in io.temporal.workflow">CancellationScope</a>&nbsp;newCancellationScope(<a href="../../../io/temporal/workflow/Functions.Proc1.html" title="interface in io.temporal.workflow">Functions.Proc1</a>&lt;<a href="../../../io/temporal/workflow/CancellationScope.html" title="interface in io.temporal.workflow">CancellationScope</a>&gt;&nbsp;proc)</pre>
<div class="block">Wraps a procedure in a CancellationScope. The procedure receives the wrapping CancellationScope
 as a parameter. Useful when cancellation is requested from within the wrapped code. The
 following example cancels the sibling activity on any failure.

 <pre><code>
               Workflow.newCancellationScope(
                   (scope) -&gt; {
                     Promise<Void> p1 = Async.proc(activities::a1).exceptionally(ex-&gt;
                        {
                           scope.cancel("a1 failed");
                           return null;
                        });

                     Promise<Void> p2 = Async.proc(activities::a2).exceptionally(ex-&gt;
                        {
                           scope.cancel("a2 failed");
                           return null;
                        });
                     Promise.allOf(p1, p2).get();
                   })
               .run();
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>proc</code> - code to wrap in the cancellation scope</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>wrapped proc</dd>
</dl>
</li>
</ul>
<a name="newDetachedCancellationScope-java.lang.Runnable-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newDetachedCancellationScope</h4>
<pre>public static&nbsp;<a href="../../../io/temporal/workflow/CancellationScope.html" title="interface in io.temporal.workflow">CancellationScope</a>&nbsp;newDetachedCancellationScope(java.lang.Runnable&nbsp;runnable)</pre>
<div class="block">Creates a CancellationScope that is not linked to a parent scope. <code>Runnable.run()</code> must be called to execute the code the scope wraps. The detached scope
 is needed to execute cleanup code after a workflow is canceled which cancels the root scope
 that wraps the @WorkflowMethod invocation. Here is an example usage:

 <pre><code>
  try {
     // workflow logic
  } catch (CanceledFailure e) {
     CancellationScope detached = Workflow.newDetachedCancellationScope(() -&gt; {
         // cleanup logic
     });
     detached.run();
  }
 </code></pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>runnable</code> - parameter to wrap in a cancellation scope.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>wrapped parameter.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../io/temporal/workflow/Workflow.html#newCancellationScope-java.lang.Runnable-"><code>newCancellationScope(Runnable)</code></a></dd>
</dl>
</li>
</ul>
<a name="newTimer-java.time.Duration-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newTimer</h4>
<pre>public static&nbsp;<a href="../../../io/temporal/workflow/Promise.html" title="interface in io.temporal.workflow">Promise</a>&lt;java.lang.Void&gt;&nbsp;newTimer(java.time.Duration&nbsp;delay)</pre>
<div class="block">Create new timer. Note that Temporal service time resolution is in seconds. So all durations
 are rounded <b>up</b> to the nearest second.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>feature that becomes ready when at least specified number of seconds passes. promise is
     failed with <a href="../../../io/temporal/failure/CanceledFailure.html" title="class in io.temporal.failure"><code>CanceledFailure</code></a> if enclosing scope is canceled.</dd>
</dl>
</li>
</ul>
<a name="newQueue-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newQueue</h4>
<pre>public static&nbsp;&lt;E&gt;&nbsp;<a href="../../../io/temporal/workflow/WorkflowQueue.html" title="interface in io.temporal.workflow">WorkflowQueue</a>&lt;E&gt;&nbsp;newQueue(int&nbsp;capacity)</pre>
</li>
</ul>
<a name="newPromise--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newPromise</h4>
<pre>public static&nbsp;&lt;E&gt;&nbsp;<a href="../../../io/temporal/workflow/CompletablePromise.html" title="interface in io.temporal.workflow">CompletablePromise</a>&lt;E&gt;&nbsp;newPromise()</pre>
</li>
</ul>
<a name="newPromise-java.lang.Object-">
<!--   -->
</a><a name="newPromise-E-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newPromise</h4>
<pre>public static&nbsp;&lt;E&gt;&nbsp;<a href="../../../io/temporal/workflow/Promise.html" title="interface in io.temporal.workflow">Promise</a>&lt;E&gt;&nbsp;newPromise(E&nbsp;value)</pre>
</li>
</ul>
<a name="newFailedPromise-java.lang.Exception-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newFailedPromise</h4>
<pre>public static&nbsp;&lt;E&gt;&nbsp;<a href="../../../io/temporal/workflow/Promise.html" title="interface in io.temporal.workflow">Promise</a>&lt;E&gt;&nbsp;newFailedPromise(java.lang.Exception&nbsp;failure)</pre>
</li>
</ul>
<a name="registerListener-java.lang.Object-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>registerListener</h4>
<pre>public static&nbsp;void&nbsp;registerListener(java.lang.Object&nbsp;listener)</pre>
<div class="block">Registers an implementation object. The object must implement at least one interface annotated
 with <a href="../../../io/temporal/workflow/WorkflowInterface.html" title="annotation in io.temporal.workflow"><code>WorkflowInterface</code></a>. All its methods annotated with @<a href="../../../io/temporal/workflow/SignalMethod.html" title="annotation in io.temporal.workflow"><code>SignalMethod</code></a>
 and @<a href="../../../io/temporal/workflow/QueryMethod.html" title="annotation in io.temporal.workflow"><code>QueryMethod</code></a> are registered.

 <p>There is no need to register the top level workflow implementation object as it is done
 implicitly by the framework on object startup.

 <p>An attempt to register a duplicated query is going to fail with <code>IllegalArgumentException</code></div>
</li>
</ul>
<a name="currentTimeMillis--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>currentTimeMillis</h4>
<pre>public static&nbsp;long&nbsp;currentTimeMillis()</pre>
<div class="block">Must be used to get current time instead of <code>System.currentTimeMillis()</code> to guarantee
 determinism.</div>
</li>
</ul>
<a name="sleep-java.time.Duration-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sleep</h4>
<pre>public static&nbsp;void&nbsp;sleep(java.time.Duration&nbsp;duration)</pre>
<div class="block">Must be called instead of <code>Thread.sleep(long)</code> to guarantee determinism.</div>
</li>
</ul>
<a name="sleep-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sleep</h4>
<pre>public static&nbsp;void&nbsp;sleep(long&nbsp;millis)</pre>
<div class="block">Must be called instead of <code>Thread.sleep(long)</code> to guarantee determinism.</div>
</li>
</ul>
<a name="await-java.util.function.Supplier-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>await</h4>
<pre>public static&nbsp;void&nbsp;await(java.util.function.Supplier&lt;java.lang.Boolean&gt;&nbsp;unblockCondition)</pre>
<div class="block">Block current thread until unblockCondition is evaluated to true.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>unblockCondition</code> - condition that should return true to indicate that thread should
     unblock. The condition is called on every state transition, so it should never call any
     blocking operations or contain code that mutates any workflow state. It should also not
     contain any time based conditions. Use <a href="../../../io/temporal/workflow/Workflow.html#await-java.time.Duration-java.util.function.Supplier-"><code>await(Duration, Supplier)</code></a> for those
     instead.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../../../io/temporal/failure/CanceledFailure.html" title="class in io.temporal.failure">CanceledFailure</a></code> - if thread (or current <a href="../../../io/temporal/workflow/CancellationScope.html" title="interface in io.temporal.workflow"><code>CancellationScope</code></a> was canceled).</dd>
</dl>
</li>
</ul>
<a name="await-java.time.Duration-java.util.function.Supplier-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>await</h4>
<pre>public static&nbsp;boolean&nbsp;await(java.time.Duration&nbsp;timeout,
                            java.util.function.Supplier&lt;java.lang.Boolean&gt;&nbsp;unblockCondition)</pre>
<div class="block">Block current workflow thread until unblockCondition is evaluated to true or timeoutMillis
 passes.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>timeout</code> - time to unblock even if unblockCondition is not satisfied.</dd>
<dd><code>unblockCondition</code> - condition that should return true to indicate that thread should
     unblock. The condition is called on every state transition, so it should not contain any
     code that mutates any workflow state. It should also not contain any time based conditions.
     Use timeout parameter for those.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>false if timed out.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../../../io/temporal/failure/CanceledFailure.html" title="class in io.temporal.failure">CanceledFailure</a></code> - if thread (or current <a href="../../../io/temporal/workflow/CancellationScope.html" title="interface in io.temporal.workflow"><code>CancellationScope</code></a> was canceled).</dd>
</dl>
</li>
</ul>
<a name="retry-io.temporal.common.RetryOptions-java.util.Optional-io.temporal.workflow.Functions.Func-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>retry</h4>
<pre>public static&nbsp;&lt;R&gt;&nbsp;R&nbsp;retry(<a href="../../../io/temporal/common/RetryOptions.html" title="class in io.temporal.common">RetryOptions</a>&nbsp;options,
                          java.util.Optional&lt;java.time.Duration&gt;&nbsp;expiration,
                          <a href="../../../io/temporal/workflow/Functions.Func.html" title="interface in io.temporal.workflow">Functions.Func</a>&lt;R&gt;&nbsp;fn)</pre>
<div class="block">Invokes function retrying in case of failures according to retry options. Synchronous variant.
 Use <a href="../../../io/temporal/workflow/Async.html#retry-io.temporal.common.RetryOptions-java.util.Optional-io.temporal.workflow.Functions.Func-"><code>Async.retry(RetryOptions, Optional, Functions.Func)</code></a> for asynchronous functions.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>options</code> - retry options that specify retry policy</dd>
<dd><code>expiration</code> - stop retrying after this interval if provided</dd>
<dd><code>fn</code> - function to invoke and retry</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>result of the function or the last failure.</dd>
</dl>
</li>
</ul>
<a name="retry-io.temporal.common.RetryOptions-java.util.Optional-io.temporal.workflow.Functions.Proc-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>retry</h4>
<pre>public static&nbsp;void&nbsp;retry(<a href="../../../io/temporal/common/RetryOptions.html" title="class in io.temporal.common">RetryOptions</a>&nbsp;options,
                         java.util.Optional&lt;java.time.Duration&gt;&nbsp;expiration,
                         <a href="../../../io/temporal/workflow/Functions.Proc.html" title="interface in io.temporal.workflow">Functions.Proc</a>&nbsp;proc)</pre>
<div class="block">Invokes function retrying in case of failures according to retry options. Synchronous variant.
 Use <a href="../../../io/temporal/workflow/Async.html#retry-io.temporal.common.RetryOptions-java.util.Optional-io.temporal.workflow.Functions.Func-"><code>Async.retry(RetryOptions, Optional, Functions.Func)</code></a> (RetryOptions, Optional, Func)}
 for asynchronous functions.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>options</code> - retry options that specify retry policy</dd>
<dd><code>expiration</code> - if specified stop retrying after this interval</dd>
<dd><code>proc</code> - procedure to invoke and retry</dd>
</dl>
</li>
</ul>
<a name="wrap-java.lang.Exception-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>wrap</h4>
<pre>public static&nbsp;java.lang.RuntimeException&nbsp;wrap(java.lang.Exception&nbsp;e)</pre>
<div class="block">If there is a need to return a checked exception from a workflow implementation do not add the
 exception to a method signature but wrap it using this method before rethrowing. The library
 code will unwrap it automatically using <a href="../../../io/temporal/workflow/Workflow.html#unwrap-java.lang.Exception-"><code>unwrap(Exception)</code></a> when propagating exception
 to a remote caller. <code>RuntimeException</code> are just returned from this method without
 modification.

 <p>The reason for such design is that returning originally thrown exception from a remote call
 (which child workflow and activity invocations are ) would not allow adding context information
 about a failure, like activity and child workflow id. So stubs always throw a subclass of
 <a href="../../../io/temporal/failure/ActivityFailure.html" title="class in io.temporal.failure"><code>ActivityFailure</code></a> from calls to an activity and subclass of <a href="../../../io/temporal/failure/ChildWorkflowFailure.html" title="class in io.temporal.failure"><code>ChildWorkflowFailure</code></a>
 from calls to a child workflow. The original exception is attached as a cause to these wrapper
 exceptions. So as exceptions are always wrapped adding checked ones to method signature causes
 more pain than benefit.

 <p>

 <pre>
 try {
     return someCall();
 } catch (Exception e) {
     throw Workflow.wrap(e);
 }
 </pre>

 *</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>CheckedExceptionWrapper if e is checked or original exception if e extends
     RuntimeException.</dd>
</dl>
</li>
</ul>
<a name="unwrap-java.lang.Exception-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unwrap</h4>
<pre>public static&nbsp;java.lang.Exception&nbsp;unwrap(java.lang.Exception&nbsp;e)</pre>
<div class="block">Removes <a href="../../../io/temporal/internal/common/CheckedExceptionWrapper.html" title="class in io.temporal.internal.common"><code>CheckedExceptionWrapper</code></a> from causal exception
 chain.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>e</code> - exception with causality chain that might contain wrapped exceptions.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>exception causality chain with CheckedExceptionWrapper removed.</dd>
</dl>
</li>
</ul>
<a name="randomUUID--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>randomUUID</h4>
<pre>public static&nbsp;java.util.UUID&nbsp;randomUUID()</pre>
<div class="block">Replay safe way to generate UUID.

 <p>Must be used instead of <code>UUID.randomUUID()</code> which relies on a random generator, thus
 leads to non deterministic code which is prohibited inside a workflow.</div>
</li>
</ul>
<a name="newRandom--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newRandom</h4>
<pre>public static&nbsp;java.util.Random&nbsp;newRandom()</pre>
<div class="block">Replay safe random numbers generator. Seeded differently for each workflow instance.</div>
</li>
</ul>
<a name="isReplaying--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isReplaying</h4>
<pre>public static&nbsp;boolean&nbsp;isReplaying()</pre>
<div class="block">True if workflow code is being replayed. <b>Warning!</b> Never make workflow logic depend on
 this flag as it is going to break determinism. The only reasonable uses for this flag are
 deduping external never failing side effects like logging or metric reporting.

 <p>This method always returns false if called from a non workflow thread.</div>
</li>
</ul>
<a name="sideEffect-java.lang.Class-io.temporal.workflow.Functions.Func-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sideEffect</h4>
<pre>public static&nbsp;&lt;R&gt;&nbsp;R&nbsp;sideEffect(java.lang.Class&lt;R&gt;&nbsp;resultClass,
                               <a href="../../../io/temporal/workflow/Functions.Func.html" title="interface in io.temporal.workflow">Functions.Func</a>&lt;R&gt;&nbsp;func)</pre>
<div class="block">Executes the provided function once, records its result into the workflow history. The recorded
 result on history will be returned without executing the provided function during replay. This
 guarantees the deterministic requirement for workflow as the exact same result will be returned
 in replay. Common use case is to run some short non-deterministic code in workflow, like
 getting random number. The only way to fail SideEffect is to panic which causes workflow task
 failure. The workflow task after timeout is rescheduled and re-executed giving SideEffect
 another chance to succeed.

 <p>Caution: do not use sideEffect function to modify any workflow state. Only use the
 SideEffect's return value. For example this code is BROKEN:

 <pre><code>
  // Bad example:
  AtomicInteger random = new AtomicInteger();
  Workflow.sideEffect(() -&gt; {
         random.set(random.nextInt(100));
         return null;
  });
  // random will always be 0 in replay, thus this code is non-deterministic
  if random.get() &lt; 50 {
         ....
  } else {
         ....
  }
 </code></pre>

 On replay the provided function is not executed, the random will always be 0, and the workflow
 could takes a different path breaking the determinism.

 <p>Here is the correct way to use sideEffect:

 <pre><code>
  // Good example:
  int random = Workflow.sideEffect(Integer.class, () -&gt; random.nextInt(100));
  if random &lt; 50 {
         ....
  } else {
         ....
  }
 </code></pre>

 If function throws any exception it is not delivered to the workflow code. It is wrapped in
 <code>Error</code> causing failure of the current workflow task.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>resultClass</code> - type of the side effect</dd>
<dd><code>func</code> - function that returns side effect value</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>value of the side effect</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../io/temporal/workflow/Workflow.html#mutableSideEffect-java.lang.String-java.lang.Class-java.util.function.BiPredicate-io.temporal.workflow.Functions.Func-"><code>mutableSideEffect(String, Class, BiPredicate, Functions.Func)</code></a></dd>
</dl>
</li>
</ul>
<a name="sideEffect-java.lang.Class-java.lang.reflect.Type-io.temporal.workflow.Functions.Func-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sideEffect</h4>
<pre>public static&nbsp;&lt;R&gt;&nbsp;R&nbsp;sideEffect(java.lang.Class&lt;R&gt;&nbsp;resultClass,
                               java.lang.reflect.Type&nbsp;resultType,
                               <a href="../../../io/temporal/workflow/Functions.Func.html" title="interface in io.temporal.workflow">Functions.Func</a>&lt;R&gt;&nbsp;func)</pre>
<div class="block">Executes the provided function once, records its result into the workflow history. The recorded
 result on history will be returned without executing the provided function during replay. This
 guarantees the deterministic requirement for workflow as the exact same result will be returned
 in replay. Common use case is to run some short non-deterministic code in workflow, like
 getting random number. The only way to fail SideEffect is to panic which causes workflow task
 failure. The workflow task after timeout is rescheduled and re-executed giving SideEffect
 another chance to succeed.

 <p>Caution: do not use sideEffect function to modify any workflow state. Only use the
 SideEffect's return value. For example this code is BROKEN:

 <pre><code>
  // Bad example:
  AtomicInteger random = new AtomicInteger();
  Workflow.sideEffect(() -&gt; {
         random.set(random.nextInt(100));
         return null;
  });
  // random will always be 0 in replay, thus this code is non-deterministic
  if random.get() &lt; 50 {
         ....
  } else {
         ....
  }
 </code></pre>

 On replay the provided function is not executed, the random will always be 0, and the workflow
 could takes a different path breaking the determinism.

 <p>Here is the correct way to use sideEffect:

 <pre><code>
  // Good example:
  int random = Workflow.sideEffect(Integer.class, () -&gt; random.nextInt(100));
  if random &lt; 50 {
         ....
  } else {
         ....
  }
 </code></pre>

 If function throws any exception it is not delivered to the workflow code. It is wrapped in
 <code>Error</code> causing failure of the current workflow task.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>resultClass</code> - class of the side effect</dd>
<dd><code>resultType</code> - type of the side effect. Differs from resultClass for generic types.</dd>
<dd><code>func</code> - function that returns side effect value</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>value of the side effect</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../io/temporal/workflow/Workflow.html#mutableSideEffect-java.lang.String-java.lang.Class-java.util.function.BiPredicate-io.temporal.workflow.Functions.Func-"><code>mutableSideEffect(String, Class, BiPredicate, Functions.Func)</code></a></dd>
</dl>
</li>
</ul>
<a name="mutableSideEffect-java.lang.String-java.lang.Class-java.util.function.BiPredicate-io.temporal.workflow.Functions.Func-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mutableSideEffect</h4>
<pre>public static&nbsp;&lt;R&gt;&nbsp;R&nbsp;mutableSideEffect(java.lang.String&nbsp;id,
                                      java.lang.Class&lt;R&gt;&nbsp;resultClass,
                                      java.util.function.BiPredicate&lt;R,R&gt;&nbsp;updated,
                                      <a href="../../../io/temporal/workflow/Functions.Func.html" title="interface in io.temporal.workflow">Functions.Func</a>&lt;R&gt;&nbsp;func)</pre>
<div class="block"><code>mutableSideEffect</code> is similar to <a href="../../../io/temporal/workflow/Workflow.html#sideEffect-java.lang.Class-io.temporal.workflow.Functions.Func-"><code>sideEffect(Class, Functions.Func)</code></a> in allowing
 calls of non-deterministic functions from workflow code.

 <p>The difference between <code>mutableSideEffect</code> and <a href="../../../io/temporal/workflow/Workflow.html#sideEffect-java.lang.Class-io.temporal.workflow.Functions.Func-"><code>sideEffect(Class,
 Functions.Func)</code></a> is that every new <code>sideEffect</code> call in non-replay mode results in a new
 marker event recorded into the history. However, <code>mutableSideEffect</code> only records a new
 marker if a value has changed. During the replay, <code>mutableSideEffect</code> will not execute
 the function again, but it will return the exact same value as it was returning during the
 non-replay run.

 <p>One good use case of <code>mutableSideEffect</code> is to access a dynamically changing config
 without breaking determinism. Even if called very frequently the config value is recorded only
 when it changes not causing any performance degradation due to a large history size.

 <p>Caution: do not use <code>mutableSideEffect</code> function to modify any workflow state. Only
 use the mutableSideEffect's return value.

 <p>If function throws any exception it is not delivered to the workflow code. It is wrapped in
 <code>Error</code> causing failure of the current workflow task.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>id</code> - unique identifier of this side effect</dd>
<dd><code>updated</code> - used to decide if a new value should be recorded. A func result is recorded only
     if call to updated with stored and a new value as arguments returns true. It is not called
     for the first value.</dd>
<dd><code>resultClass</code> - class of the side effect</dd>
<dd><code>func</code> - function that produces a value. This function can contain non deterministic code.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../io/temporal/workflow/Workflow.html#sideEffect-java.lang.Class-io.temporal.workflow.Functions.Func-"><code>sideEffect(Class, Functions.Func)</code></a></dd>
</dl>
</li>
</ul>
<a name="mutableSideEffect-java.lang.String-java.lang.Class-java.lang.reflect.Type-java.util.function.BiPredicate-io.temporal.workflow.Functions.Func-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mutableSideEffect</h4>
<pre>public static&nbsp;&lt;R&gt;&nbsp;R&nbsp;mutableSideEffect(java.lang.String&nbsp;id,
                                      java.lang.Class&lt;R&gt;&nbsp;resultClass,
                                      java.lang.reflect.Type&nbsp;resultType,
                                      java.util.function.BiPredicate&lt;R,R&gt;&nbsp;updated,
                                      <a href="../../../io/temporal/workflow/Functions.Func.html" title="interface in io.temporal.workflow">Functions.Func</a>&lt;R&gt;&nbsp;func)</pre>
<div class="block"><code>mutableSideEffect</code> is similar to <a href="../../../io/temporal/workflow/Workflow.html#sideEffect-java.lang.Class-io.temporal.workflow.Functions.Func-"><code>sideEffect(Class, Functions.Func)</code></a> in allowing
 calls of non-deterministic functions from workflow code.

 <p>The difference between <code>mutableSideEffect</code> and <a href="../../../io/temporal/workflow/Workflow.html#sideEffect-java.lang.Class-io.temporal.workflow.Functions.Func-"><code>sideEffect(Class,
 Functions.Func)</code></a> is that every new <code>sideEffect</code> call in non-replay mode results in a new
 marker event recorded into the history. However, <code>mutableSideEffect</code> only records a new
 marker if a value has changed. During the replay, <code>mutableSideEffect</code> will not execute
 the function again, but it will return the exact same value as it was returning during the
 non-replay run.

 <p>One good use case of <code>mutableSideEffect</code> is to access a dynamically changing config
 without breaking determinism. Even if called very frequently the config value is recorded only
 when it changes not causing any performance degradation due to a large history size.

 <p>Caution: do not use <code>mutableSideEffect</code> function to modify any workflow state. Only
 use the mutableSideEffect's return value.

 <p>If function throws any exception it is not delivered to the workflow code. It is wrapped in
 <code>Error</code> causing failure of the current workflow task.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>id</code> - unique identifier of this side effect</dd>
<dd><code>updated</code> - used to decide if a new value should be recorded. A func result is recorded only
     if call to updated with stored and a new value as arguments returns true. It is not called
     for the first value.</dd>
<dd><code>resultClass</code> - class of the side effect</dd>
<dd><code>resultType</code> - type of the side effect. Differs from resultClass for generic types.</dd>
<dd><code>func</code> - function that produces a value. This function can contain non deterministic code.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../io/temporal/workflow/Workflow.html#sideEffect-java.lang.Class-io.temporal.workflow.Functions.Func-"><code>sideEffect(Class, Functions.Func)</code></a></dd>
</dl>
</li>
</ul>
<a name="getVersion-java.lang.String-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getVersion</h4>
<pre>public static&nbsp;int&nbsp;getVersion(java.lang.String&nbsp;changeId,
                             int&nbsp;minSupported,
                             int&nbsp;maxSupported)</pre>
<div class="block"><code>getVersion</code> is used to safely perform backwards incompatible changes to workflow
 definitions. It is not allowed to update workflow code while there are workflows running as it
 is going to break determinism. The solution is to have both old code that is used to replay
 existing workflows as well as the new one that is used when it is executed for the first time.\

 <p><code>getVersion</code> returns maxSupported version when is executed for the first time. This
 version is recorded into the workflow history as a marker event. Even if maxSupported version
 is changed the version that was recorded is returned on replay. DefaultVersion constant
 contains version of code that wasn't versioned before.

 <p>For example initially workflow has the following code:

 <pre><code>
 result = testActivities.activity1();
 </code></pre>

 it should be updated to

 <pre><code>
 result = testActivities.activity2();
 </code></pre>

 The backwards compatible way to execute the update is

 <pre><code>
 int version = Workflow.getVersion("fooChange", Workflow.DEFAULT_VERSION, 1);
 String result;
 if (version == Workflow.DEFAULT_VERSION) {
   result = testActivities.activity1();
 } else {
   result = testActivities.activity2();
 }
 </code></pre>

 Then later if we want to have another change:

 <pre><code>
 int version = Workflow.getVersion("fooChange", Workflow.DEFAULT_VERSION, 2);
 String result;
 if (version == Workflow.DEFAULT_VERSION) {
   result = testActivities.activity1();
 } else if (version == 1) {
   result = testActivities.activity2();
 } else {
   result = testActivities.activity3();
 }
 </code></pre>

 Later when there are no workflow executions running DefaultVersion the correspondent branch can
 be removed:

 <pre><code>
 int version = Workflow.getVersion("fooChange", 1, 2);
 String result;
 if (version == 1) {
   result = testActivities.activity2();
 } else {
   result = testActivities.activity3();
 }
 </code></pre>

 It is recommended to keep the GetVersion() call even if single branch is left:

 <pre><code>
 Workflow.getVersion("fooChange", 2, 2);
 result = testActivities.activity3();
 </code></pre>

 The reason to keep it is: 1) it ensures that if there is older version execution still running,
 it will fail here and not proceed; 2) if you ever need to make more changes for “fooChange”,
 for example change activity3 to activity4, you just need to update the maxVersion from 2 to 3.

 <p>Note that, you only need to preserve the first call to GetVersion() for each changeId. All
 subsequent call to GetVersion() with same changeId are safe to remove. However, if you really
 want to get rid of the first GetVersion() call as well, you can do so, but you need to make
 sure: 1) all older version executions are completed; 2) you can no longer use “fooChange” as
 changeId. If you ever need to make changes to that same part, you would need to use a different
 changeId like “fooChange-fix2”, and start minVersion from DefaultVersion again.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>changeId</code> - identifier of a particular change. All calls to getVersion that share a
     changeId are guaranteed to return the same version number. Use this to perform multiple
     coordinated changes that should be enabled together.</dd>
<dd><code>minSupported</code> - min version supported for the change</dd>
<dd><code>maxSupported</code> - max version supported for the change</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>version</dd>
</dl>
</li>
</ul>
<a name="getMetricsScope--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMetricsScope</h4>
<pre>public static&nbsp;com.uber.m3.tally.Scope&nbsp;getMetricsScope()</pre>
<div class="block">Get scope for reporting business metrics in workflow logic. This should be used instead of
 creating new metrics scopes as it is able to dedup metrics during replay.

 <p>The original metrics scope is set through <a href="../../../io/temporal/worker/WorkerOptions.html" title="class in io.temporal.worker"><code>WorkerOptions</code></a> when a worker starts up.</div>
</li>
</ul>
<a name="getLogger-java.lang.Class-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLogger</h4>
<pre>public static&nbsp;org.slf4j.Logger&nbsp;getLogger(java.lang.Class&lt;?&gt;&nbsp;clazz)</pre>
<div class="block">Get logger to use inside workflow. Logs in replay mode are omitted unless enableLoggingInReplay
 is set to true in <a href="../../../io/temporal/worker/WorkerOptions.html" title="class in io.temporal.worker"><code>WorkerOptions</code></a> when a worker starts up.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>clazz</code> - class name to appear in logging.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>logger to use in workflow logic.</dd>
</dl>
</li>
</ul>
<a name="getLogger-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLogger</h4>
<pre>public static&nbsp;org.slf4j.Logger&nbsp;getLogger(java.lang.String&nbsp;name)</pre>
<div class="block">Get logger to use inside workflow. Logs in replay mode are omitted unless enableLoggingInReplay
 is set to true in <a href="../../../io/temporal/worker/WorkerOptions.html" title="class in io.temporal.worker"><code>WorkerOptions</code></a> when a worker starts up.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>name</code> - name to appear in logging.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>logger to use in workflow logic.</dd>
</dl>
</li>
</ul>
<a name="getLastCompletionResult-java.lang.Class-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLastCompletionResult</h4>
<pre>public static&nbsp;&lt;R&gt;&nbsp;R&nbsp;getLastCompletionResult(java.lang.Class&lt;R&gt;&nbsp;resultClass)</pre>
<div class="block">GetLastCompletionResult extract last completion result from previous run for this cron
 workflow. This is used in combination with cron schedule. A workflow can be started with an
 optional cron schedule. If a cron workflow wants to pass some data to next schedule, it can
 return any data and that data will become available when next run starts.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>resultClass</code> - class of the return data from last run</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>result of last run</dd>
</dl>
</li>
</ul>
<a name="getLastCompletionResult-java.lang.Class-java.lang.reflect.Type-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLastCompletionResult</h4>
<pre>public static&nbsp;&lt;R&gt;&nbsp;R&nbsp;getLastCompletionResult(java.lang.Class&lt;R&gt;&nbsp;resultClass,
                                            java.lang.reflect.Type&nbsp;resultType)</pre>
<div class="block">GetLastCompletionResult extract last completion result from previous run for this cron
 workflow. This is used in combination with cron schedule. A workflow can be started with an
 optional cron schedule. If a cron workflow wants to pass some data to next schedule, it can
 return any data and that data will become available when next run starts.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>resultClass</code> - class of the return data from last run</dd>
<dd><code>resultType</code> - type of the return data from last run. Differs from resultClass for generic
     types.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>result of last run</dd>
</dl>
</li>
</ul>
<a name="upsertSearchAttributes-java.util.Map-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>upsertSearchAttributes</h4>
<pre>public static&nbsp;void&nbsp;upsertSearchAttributes(java.util.Map&lt;java.lang.String,java.lang.Object&gt;&nbsp;searchAttributes)</pre>
<div class="block"><code>upsertSearchAttributes</code> is used to add or update workflow search attributes. The search
 attributes can be used in query of List/Scan/Count workflow APIs. The key and value type must
 be registered on Temporal server side; The value has to be Json serializable.
 UpsertSearchAttributes will merge attributes to existing map in workflow, for example workflow
 code:

 <pre><code>
     Map&lt;String, Object&gt; attr1 = new HashMap&lt;&gt;();
     attr1.put("CustomIntField", 1);
     attr1.put("CustomBoolField", true);
     Workflow.upsertSearchAttributes(attr1);

     Map&lt;String, Object&gt; attr2 = new HashMap&lt;&gt;();
     attr2.put("CustomIntField", 2);
     attr2.put("CustomKeywordField", "Seattle");
     Workflow.upsertSearchAttributes(attr2);
 </pre></code> will eventually have search attributes as:

 <pre><code>
     {
       "CustomIntField": 2,
       "CustomBoolField": true,
       "CustomKeywordField": "Seattle",
     }
 </pre></code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>searchAttributes</code> - map of String to Object value that can be used to search in list APIs</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../io/temporal/workflow/SignalMethod.html" title="annotation in io.temporal.workflow"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../io/temporal/workflow/WorkflowInfo.html" title="interface in io.temporal.workflow"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?io/temporal/workflow/Workflow.html" target="_top">Frames</a></li>
<li><a href="Workflow.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
