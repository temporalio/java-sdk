<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>Activity (sdk 0.29.1-SNAPSHOT API)</title>
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Activity (sdk 0.29.1-SNAPSHOT API)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":9,"i1":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev&nbsp;Class</li>
<li><a href="../../../io/temporal/activity/ActivityCancellationType.html" title="enum in io.temporal.activity"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?io/temporal/activity/Activity.html" target="_top">Frames</a></li>
<li><a href="Activity.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">io.temporal.activity</div>
<h2 title="Class Activity" class="title">Class Activity</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>io.temporal.activity.Activity</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public final class <span class="typeNameLabel">Activity</span>
extends java.lang.Object</pre>
<div class="block">An activity is the implementation of a particular task in the business logic.

 <h2>Activity Interface</h2>

 <p>Activities are defined as methods of a plain Java interface annotated with @<a href="../../../io/temporal/activity/ActivityInterface.html" title="annotation in io.temporal.activity"><code>ActivityInterface</code></a>. Each method defines a single activity type. A single workflow can use more
 than one activity interface and call more than one activity method from the same interface. The
 only requirement is that activity method arguments and return values are serializable to a byte
 array using the provided <a href="../../../io/temporal/common/converter/DataConverter.html" title="interface in io.temporal.common.converter"><code>DataConverter</code></a> implementation. The
 default implementation uses JSON serializer, but an alternative implementation can be configured
 through <a href="../../../io/temporal/client/WorkflowClientOptions.Builder.html#setDataConverter-io.temporal.common.converter.DataConverter-"><code>WorkflowClientOptions.Builder.setDataConverter(DataConverter)</code></a>.

 <p>Example of an interface that defines four activities:

 <pre><code>
  @ActivityInterface
 public interface FileProcessingActivities {

     void upload(String bucketName, String localName, String targetName);

     String download(String bucketName, String remoteName);

      @ActivityMethod(name = "Transcode")
     String processFile(String localName);

     void deleteLocalFile(String fileName);
 }

 </code></pre>

 An optional @<a href="../../../io/temporal/activity/ActivityMethod.html" title="annotation in io.temporal.activity"><code>ActivityMethod</code></a> annotation can be used to specify activity name.
 By default the method name with the first letter capitalized is used as an activity name. So the
 above interface defines the following activities: "Upload", "Download", "Transcode" and
 "DeleteLocalFile".

 <h2>Activity Implementation</h2>

 <p>Activity implementation is an implementation of an activity interface. A single instance of
 the activity's implementation is shared across multiple simultaneous activity invocations.
 Therefore, the activity implementation code must be <i>thread safe</i>.

 <p>The values passed to activities through invocation parameters or returned through a result
 value are recorded in the execution history. The entire execution history is transferred from the
 Temporal service to workflow workers when a workflow state needs to recover. A large execution
 history can thus adversely impact the performance of your workflow. Therefore, be mindful of the
 amount of data you transfer via activity invocation parameters or return values. Other than that,
 no additional limitations exist on activity implementations.

 <pre><code>
 public class FileProcessingActivitiesImpl implements FileProcessingActivities {

     private final AmazonS3 s3Client;

     private final String localDirectory;

     void upload(String bucketName, String localName, String targetName) {
         File f = new File(localName);
         s3Client.putObject(bucket, remoteName, f);
     }

     String download(String bucketName, String remoteName, String localName) {
         // Implementation omitted for brevity.
         return downloadFileFromS3(bucketName, remoteName, localDirectory + localName);
     }

     String processFile(String localName) {
         // Implementation omitted for brevity.
         return compressFile(localName);
     }

     void deleteLocalFile(String fileName) {
         File f = new File(localDirectory + fileName);
         f.delete();
     }
 }
 </code></pre>

 <h3>Accessing Activity Info</h3>

 <p>The <a href="../../../io/temporal/activity/Activity.html#getExecutionContext--"><code>getExecutionContext()</code></a> returns <a href="../../../io/temporal/activity/ActivityExecutionContext.html" title="interface in io.temporal.activity"><code>ActivityExecutionContext</code></a> which
 provides static getters to access information about the workflow that invoked it. Note that the
 activity context information is stored in a thread-local variable. Therefore, calls to <a href="../../../io/temporal/activity/Activity.html#getExecutionContext--"><code>getExecutionContext()</code></a> succeeds only in the thread that invoked the activity function.

 <pre><code>
 public class FileProcessingActivitiesImpl implements FileProcessingActivities {

       @Override
      public String download(String bucketName, String remoteName, String localName) {
         ActivityExecutionContext ctx = Activity.getExecutionContext();
         ActivityInfo info = ctx.getInfo();
         log.info("namespace=" +  info.getActivityNamespace());
         log.info("workflowId=" + info.getWorkflowId());
         log.info("runId=" + info.getRunId());
         log.info("activityId=" + info.getActivityId());
         log.info("activityTimeout=" + info.getStartToCloseTimeoutSeconds());
         return downloadFileFromS3(bucketName, remoteName, localDirectory + localName);
      }
      ...
  }
 </code></pre>

 <h3>Asynchronous Activity Completion</h3>

 <p>Sometimes an activity lifecycle goes beyond a synchronous method invocation. For example, a
 request can be put in a queue and later a reply comes and is picked up by a different worker
 process. The whole request-reply interaction can be modeled as a single Temporal activity.

 <p>To indicate that an activity should not be completed upon its method return, call <a href="../../../io/temporal/activity/ActivityExecutionContext.html#doNotCompleteOnReturn--"><code>ActivityExecutionContext.doNotCompleteOnReturn()</code></a> from the original activity thread. Then later,
 when replies come, complete the activity using <a href="../../../io/temporal/client/ActivityCompletionClient.html" title="interface in io.temporal.client"><code>ActivityCompletionClient</code></a>. To correlate activity invocation with completion
 use either <code>TaskToken</code> or workflow and activity IDs.

 <pre><code>
 public class FileProcessingActivitiesImpl implements FileProcessingActivities {

      public String download(String bucketName, String remoteName, String localName) {
          ActivityExecutionContext ctx = Activity.getExecutionContext();
          byte[] taskToken = ctx.getInfo().getTaskToken(); // Used to correlate reply
          asyncDownloadFileFromS3(taskToken, bucketName, remoteName, localDirectory + localName);
          ctx.doNotCompleteOnReturn();
          return "ignored"; // Return value is ignored when doNotCompleteOnReturn was called.
      }
      ...
 }
 </code></pre>

 When the download is complete, the download service potentially calls back from a different
 process:

 <pre><code>
     public <R> void completeActivity(byte[] taskToken, R result) {
         completionClient.complete(taskToken, result);
     }

     public void failActivity(byte[] taskToken, Exception failure) {
         completionClient.completeExceptionally(taskToken, failure);
     }
 </code></pre>

 <h3>Activity Heartbeating</h3>

 <p>Some activities are long running. To react to their crashes quickly, use a heartbeat
 mechanism. Use the <a href="../../../io/temporal/activity/ActivityExecutionContext.html#heartbeat-V-"><code>ActivityExecutionContext.heartbeat(Object)</code></a> function to let the
 Temporal service know that the activity is still alive. You can piggyback `details` on an
 activity heartbeat. If an activity times out, the last value of `details` is included in the
 ActivityTimeoutException delivered to a workflow. Then the workflow can pass the details to the
 next activity invocation. This acts as a periodic checkpointing mechanism of an activity's
 progress.

 <pre><code>
 public class FileProcessingActivitiesImpl implements FileProcessingActivities {

       @Override
      public String download(String bucketName, String remoteName, String localName) {
         InputStream inputStream = openInputStream(file);
         try {
             byte[] bytes = new byte[MAX_BUFFER_SIZE];
             while ((read = inputStream.read(bytes)) != -1) {
                 totalRead += read;
                 f.write(bytes, 0, read);
                 // Let the service know about the download progress.
                 Activity.getExecutionContext().heartbeat(totalRead);
             }
         }finally{
             inputStream.close();
         }
      }
      ...
 }
 </code></pre></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../io/temporal/worker/Worker.html" title="class in io.temporal.worker"><code>Worker</code></a>, 
<a href="../../../io/temporal/workflow/Workflow.html" title="class in io.temporal.workflow"><code>Workflow</code></a>, 
<a href="../../../io/temporal/client/WorkflowClient.html" title="interface in io.temporal.client"><code>WorkflowClient</code></a></dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>static <a href="../../../io/temporal/activity/ActivityExecutionContext.html" title="interface in io.temporal.activity">ActivityExecutionContext</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/activity/Activity.html#getExecutionContext--">getExecutionContext</a></span>()</code>
<div class="block">Activity execution context.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static java.lang.RuntimeException</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/temporal/activity/Activity.html#wrap-java.lang.Throwable-">wrap</a></span>(java.lang.Throwable&nbsp;e)</code>
<div class="block">If there is a need to return a checked exception from an activity do not add the exception to a
 method signature but rethrow it using this method.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="getExecutionContext--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getExecutionContext</h4>
<pre>public static&nbsp;<a href="../../../io/temporal/activity/ActivityExecutionContext.html" title="interface in io.temporal.activity">ActivityExecutionContext</a>&nbsp;getExecutionContext()</pre>
<div class="block">Activity execution context. It can be used to get information about activity invocation as well
 for heartbeating.

 <p>Note: This static method relies on a thread local and works only in the original activity
 thread.</div>
</li>
</ul>
<a name="wrap-java.lang.Throwable-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>wrap</h4>
<pre>public static&nbsp;java.lang.RuntimeException&nbsp;wrap(java.lang.Throwable&nbsp;e)</pre>
<div class="block">If there is a need to return a checked exception from an activity do not add the exception to a
 method signature but rethrow it using this method. The library code will unwrap it
 automatically when propagating exception to the caller. There is no need to wrap unchecked
 exceptions, but it is safe to call this method on them.

 <p>The reason for such design is that returning originally thrown exception from a remote call
 (which child workflow and activity invocations are ) would not allow adding context information
 about a failure, like activity and child workflow id. So stubs always throw a subclass of
 <a href="../../../io/temporal/failure/ActivityFailure.html" title="class in io.temporal.failure"><code>ActivityFailure</code></a> from calls to an activity and subclass of <a href="../../../io/temporal/failure/ChildWorkflowFailure.html" title="class in io.temporal.failure"><code>ChildWorkflowFailure</code></a>
 from calls to a child workflow. The original exception is attached as a cause to these wrapper
 exceptions. So as exceptions are always wrapped adding checked ones to method signature causes
 more pain than benefit.

 <p>Throws original exception if e is <code>RuntimeException</code> or <code>Error</code>. Never returns.
 But return type is not empty to be able to use it as:

 <pre>
 try {
     return someCall();
 } catch (Exception e) {
     throw Activity.wrap(e);
 }
 </pre>

 If wrap returned void it wouldn't be possible to write <code>
 throw Activity.wrap</code> and compiler would complain about missing return.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>never returns as always throws.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev&nbsp;Class</li>
<li><a href="../../../io/temporal/activity/ActivityCancellationType.html" title="enum in io.temporal.activity"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?io/temporal/activity/Activity.html" target="_top">Frames</a></li>
<li><a href="Activity.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
