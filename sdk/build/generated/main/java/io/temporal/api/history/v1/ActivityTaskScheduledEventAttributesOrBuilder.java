// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: temporal/api/history/v1/message.proto

package io.temporal.api.history.v1;

public interface ActivityTaskScheduledEventAttributesOrBuilder extends
    // @@protoc_insertion_point(interface_extends:temporal.api.history.v1.ActivityTaskScheduledEventAttributes)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <code>string activity_id = 1;</code>
   * @return The activityId.
   */
  java.lang.String getActivityId();
  /**
   * <code>string activity_id = 1;</code>
   * @return The bytes for activityId.
   */
  com.google.protobuf.ByteString
      getActivityIdBytes();

  /**
   * <code>.temporal.api.common.v1.ActivityType activity_type = 2;</code>
   * @return Whether the activityType field is set.
   */
  boolean hasActivityType();
  /**
   * <code>.temporal.api.common.v1.ActivityType activity_type = 2;</code>
   * @return The activityType.
   */
  io.temporal.api.common.v1.ActivityType getActivityType();
  /**
   * <code>.temporal.api.common.v1.ActivityType activity_type = 2;</code>
   */
  io.temporal.api.common.v1.ActivityTypeOrBuilder getActivityTypeOrBuilder();

  /**
   * <code>string namespace = 3;</code>
   * @return The namespace.
   */
  java.lang.String getNamespace();
  /**
   * <code>string namespace = 3;</code>
   * @return The bytes for namespace.
   */
  com.google.protobuf.ByteString
      getNamespaceBytes();

  /**
   * <code>.temporal.api.taskqueue.v1.TaskQueue task_queue = 4;</code>
   * @return Whether the taskQueue field is set.
   */
  boolean hasTaskQueue();
  /**
   * <code>.temporal.api.taskqueue.v1.TaskQueue task_queue = 4;</code>
   * @return The taskQueue.
   */
  io.temporal.api.taskqueue.v1.TaskQueue getTaskQueue();
  /**
   * <code>.temporal.api.taskqueue.v1.TaskQueue task_queue = 4;</code>
   */
  io.temporal.api.taskqueue.v1.TaskQueueOrBuilder getTaskQueueOrBuilder();

  /**
   * <code>.temporal.api.common.v1.Header header = 5;</code>
   * @return Whether the header field is set.
   */
  boolean hasHeader();
  /**
   * <code>.temporal.api.common.v1.Header header = 5;</code>
   * @return The header.
   */
  io.temporal.api.common.v1.Header getHeader();
  /**
   * <code>.temporal.api.common.v1.Header header = 5;</code>
   */
  io.temporal.api.common.v1.HeaderOrBuilder getHeaderOrBuilder();

  /**
   * <code>.temporal.api.common.v1.Payloads input = 6;</code>
   * @return Whether the input field is set.
   */
  boolean hasInput();
  /**
   * <code>.temporal.api.common.v1.Payloads input = 6;</code>
   * @return The input.
   */
  io.temporal.api.common.v1.Payloads getInput();
  /**
   * <code>.temporal.api.common.v1.Payloads input = 6;</code>
   */
  io.temporal.api.common.v1.PayloadsOrBuilder getInputOrBuilder();

  /**
   * <pre>
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   * Indicates how long the caller is willing to wait for an activity completion.
   * Limits for how long retries are happening. Either this or start_to_close_timeout_seconds must be specified.
   * </pre>
   *
   * <code>.google.protobuf.Duration schedule_to_close_timeout = 7 [(.gogoproto.stdduration) = true];</code>
   * @return Whether the scheduleToCloseTimeout field is set.
   */
  boolean hasScheduleToCloseTimeout();
  /**
   * <pre>
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   * Indicates how long the caller is willing to wait for an activity completion.
   * Limits for how long retries are happening. Either this or start_to_close_timeout_seconds must be specified.
   * </pre>
   *
   * <code>.google.protobuf.Duration schedule_to_close_timeout = 7 [(.gogoproto.stdduration) = true];</code>
   * @return The scheduleToCloseTimeout.
   */
  com.google.protobuf.Duration getScheduleToCloseTimeout();
  /**
   * <pre>
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   * Indicates how long the caller is willing to wait for an activity completion.
   * Limits for how long retries are happening. Either this or start_to_close_timeout_seconds must be specified.
   * </pre>
   *
   * <code>.google.protobuf.Duration schedule_to_close_timeout = 7 [(.gogoproto.stdduration) = true];</code>
   */
  com.google.protobuf.DurationOrBuilder getScheduleToCloseTimeoutOrBuilder();

  /**
   * <pre>
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   * Limits time an activity task can stay in a task queue before a worker picks it up.
   * This timeout is always non retryable as all a retry would achieve is to put it back into the same queue.
   * Defaults to schedule_to_close_timeout_seconds or workflow execution timeout if not specified.
   * </pre>
   *
   * <code>.google.protobuf.Duration schedule_to_start_timeout = 8 [(.gogoproto.stdduration) = true];</code>
   * @return Whether the scheduleToStartTimeout field is set.
   */
  boolean hasScheduleToStartTimeout();
  /**
   * <pre>
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   * Limits time an activity task can stay in a task queue before a worker picks it up.
   * This timeout is always non retryable as all a retry would achieve is to put it back into the same queue.
   * Defaults to schedule_to_close_timeout_seconds or workflow execution timeout if not specified.
   * </pre>
   *
   * <code>.google.protobuf.Duration schedule_to_start_timeout = 8 [(.gogoproto.stdduration) = true];</code>
   * @return The scheduleToStartTimeout.
   */
  com.google.protobuf.Duration getScheduleToStartTimeout();
  /**
   * <pre>
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   * Limits time an activity task can stay in a task queue before a worker picks it up.
   * This timeout is always non retryable as all a retry would achieve is to put it back into the same queue.
   * Defaults to schedule_to_close_timeout_seconds or workflow execution timeout if not specified.
   * </pre>
   *
   * <code>.google.protobuf.Duration schedule_to_start_timeout = 8 [(.gogoproto.stdduration) = true];</code>
   */
  com.google.protobuf.DurationOrBuilder getScheduleToStartTimeoutOrBuilder();

  /**
   * <pre>
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   * Maximum time an activity is allowed to execute after a pick up by a worker.
   * This timeout is always retryable. Either this or schedule_to_close_timeout_seconds must be specified.
   * </pre>
   *
   * <code>.google.protobuf.Duration start_to_close_timeout = 9 [(.gogoproto.stdduration) = true];</code>
   * @return Whether the startToCloseTimeout field is set.
   */
  boolean hasStartToCloseTimeout();
  /**
   * <pre>
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   * Maximum time an activity is allowed to execute after a pick up by a worker.
   * This timeout is always retryable. Either this or schedule_to_close_timeout_seconds must be specified.
   * </pre>
   *
   * <code>.google.protobuf.Duration start_to_close_timeout = 9 [(.gogoproto.stdduration) = true];</code>
   * @return The startToCloseTimeout.
   */
  com.google.protobuf.Duration getStartToCloseTimeout();
  /**
   * <pre>
   * (-- api-linter: core::0140::prepositions=disabled
   *     aip.dev/not-precedent: "to" is used to indicate interval. --)
   * Maximum time an activity is allowed to execute after a pick up by a worker.
   * This timeout is always retryable. Either this or schedule_to_close_timeout_seconds must be specified.
   * </pre>
   *
   * <code>.google.protobuf.Duration start_to_close_timeout = 9 [(.gogoproto.stdduration) = true];</code>
   */
  com.google.protobuf.DurationOrBuilder getStartToCloseTimeoutOrBuilder();

  /**
   * <pre>
   * Maximum time between successful worker heartbeats.
   * </pre>
   *
   * <code>.google.protobuf.Duration heartbeat_timeout = 10 [(.gogoproto.stdduration) = true];</code>
   * @return Whether the heartbeatTimeout field is set.
   */
  boolean hasHeartbeatTimeout();
  /**
   * <pre>
   * Maximum time between successful worker heartbeats.
   * </pre>
   *
   * <code>.google.protobuf.Duration heartbeat_timeout = 10 [(.gogoproto.stdduration) = true];</code>
   * @return The heartbeatTimeout.
   */
  com.google.protobuf.Duration getHeartbeatTimeout();
  /**
   * <pre>
   * Maximum time between successful worker heartbeats.
   * </pre>
   *
   * <code>.google.protobuf.Duration heartbeat_timeout = 10 [(.gogoproto.stdduration) = true];</code>
   */
  com.google.protobuf.DurationOrBuilder getHeartbeatTimeoutOrBuilder();

  /**
   * <code>int64 workflow_task_completed_event_id = 11;</code>
   * @return The workflowTaskCompletedEventId.
   */
  long getWorkflowTaskCompletedEventId();

  /**
   * <pre>
   * Activities are provided by a default retry policy controlled through the service dynamic configuration.
   * Retries are happening up to schedule_to_close_timeout.
   * To disable retries set retry_policy.maximum_attempts to 1.
   * </pre>
   *
   * <code>.temporal.api.common.v1.RetryPolicy retry_policy = 12;</code>
   * @return Whether the retryPolicy field is set.
   */
  boolean hasRetryPolicy();
  /**
   * <pre>
   * Activities are provided by a default retry policy controlled through the service dynamic configuration.
   * Retries are happening up to schedule_to_close_timeout.
   * To disable retries set retry_policy.maximum_attempts to 1.
   * </pre>
   *
   * <code>.temporal.api.common.v1.RetryPolicy retry_policy = 12;</code>
   * @return The retryPolicy.
   */
  io.temporal.api.common.v1.RetryPolicy getRetryPolicy();
  /**
   * <pre>
   * Activities are provided by a default retry policy controlled through the service dynamic configuration.
   * Retries are happening up to schedule_to_close_timeout.
   * To disable retries set retry_policy.maximum_attempts to 1.
   * </pre>
   *
   * <code>.temporal.api.common.v1.RetryPolicy retry_policy = 12;</code>
   */
  io.temporal.api.common.v1.RetryPolicyOrBuilder getRetryPolicyOrBuilder();
}
